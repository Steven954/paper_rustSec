# 第一章 绪论

## 1.1 研究背景与意义

随着编程语言的发展，错误处理机制经历了从最初简单返回错误码到引入异常（Exception）的演进。传统语言如 C++、Java 等使用异常来应对运行时错误，当出现异常时程序会进行栈展开（stack unwinding），逐层清理函数调用栈上的资源。这种机制虽然简化了正常情况下的错误检查，但也带来了异常安全的问题：异常会中断程序的正常控制流，若资源清理或状态维护不当，可能导致程序崩溃或资源泄漏等安全隐患。为此，C++ 社区提出了异常安全（exception safety）准则，例如要求代码满足基本异常安全或强异常安全保证，以确保在异常发生时保持程序状态一致或至少不破坏内存安全。

近年来，新兴编程语言开始反思传统异常模型的不足，转向更加显式和安全的错误处理方式。Rust 语言正是其中的佼佼者：它以内存安全和可靠性著称，引入了独特的错误处理双机制，即区分可恢复错误和不可恢复错误。对于可预期且可处理的错误，Rust 采用 Result 类型通过返回值进行传递，鼓励开发者显式地检查和处理错误，从而使错误控制流在源代码中清晰可见。而对于不可恢复的错误条件，Rust 提供了恐慌（panic）机制——这类似于其他语言的异常，但语义上表示程序已进入不可挽回的错误状态。当出现 panic! 时，Rust 会阻止函数按常规返回，转而触发运行时的恐慌过程。默认情况下，恐慌会引发栈展开，清理当前线程调用栈上的所有栈帧，并最终终止程序（或线程）执行。与 Java/C# 等不同，Rust 的函数签名中不标记会发生恐慌，这意味着恐慌的发生对读代码的人而言是隐式的。因此，Rust 的恐慌机制具有双重特性：一方面，它提供了类似异常的便利，在必要情况下自动清理资源；另一方面，它使得控制流出现非本地跳转，若处理不当将埋下内存安全隐患。这种特殊性决定了对 Rust 恐慌机制的研究具有重要意义。

Rust 语言通过严格的编译期检查（所有权和借用规则等）来保障绝大多数内存安全问题在编译阶段被杜绝。然而，这一安全保障建立在正常控制流的前提下，即假设代码按顺序执行直至函数正常返回。如果程序在中途发生恐慌并展开栈，情况就变得更为复杂。在栈展开过程中，所有在展开路径上活动的对象都会执行其析构函数（Drop），以释放资源。按理说，这种设计确保了就算发生异常情况，资源也不会泄漏——未访问的对象被像正常退出一样处理掉。然而，当恐慌遇上 Drop、unsafe 代码或 FFI 接口时，原本的安全保障可能失效，引入新的风险。本质原因在于：恐慌改变了程序的控制流和执行时机，从而打破了一些代码对执行顺序的假设，进而导致内存安全问题。

首先，考虑恐慌与析构（Drop）的交互。Rust 鼓励 RAII 惯用法，资源的释放放在对象析构中自动进行。然而如果一个对象的析构过程未预见到半途中止的情况（例如析构函数内部或相关代码发生了恐慌），可能会产生**“双重释放”**或部分清理的问题。例如，当恐慌发生时，某些对象的析构函数可能已经执行过资源释放操作，如果同一资源稍后再次释放，就会造成严重的内存错误（双重释放），破坏内存状态。标准库对此已有前车之鉴：例如早期版本的 String::retain 方法中，如果在内部迭代时发生 panic，会导致字符串长度不一致，从而在后续的内存操作中出现未定义行为，最终被报告为 CVE-2020-36317 内存安全漏洞。因此，Rust 社区引入了恐慌安全（panic safety）概念，对应于 C++ 的异常安全，但专指由 panic 引发的安全性问题。恐慌安全要求即使发生 panic，程序也不应违反内存安全或产生难以恢复的不一致状态。保障恐慌安全在 Rust 中尤为关键，因为 Rust 旨在提供“无悬空指针、无数据竞态”的安全保证，若 panic 路径下出现内存错误，将直接动摇 Rust 安全性的根基。

其次，恐慌与 unsafe 代码的耦合进一步放大了风险。在安全 Rust 代码中，编译器检查可以防止绝大多数违反内存安全的操作；但在 unsafe 块内部，这些检查被显式关闭，程序员需自行确保不发生未定义行为。许多 unsafe 代码片段会假定某些操作序列不会被中断——例如先暂时破坏某些不变式，然后执行一系列操作复原状态，最后恢复不变式。如果在这一过程中突然发生恐慌，外部的安全检查往往尚未来得及执行或根本无从知晓内部状态的紊乱。这样，unsafe 代码可能在恐慌时留下悬空指针、未初始化内存或双重释放等隐患。正如文献所指出的：“封装的 Unsafe 代码在返回安全结果之前，往往依赖一些内部假设来保证不违反安全规则；但若封装内部发生恐慌，外部的安全检查可能永远不会执行，从而很可能导致类似 C/C++ 中的未初始化或双重释放内存问题”。这说明，在 Rust 的安全模型中，unsafe 代码对恐慌缺乏天然抵御能力，需要特别的小心和约束。例如，Rust 提供了 std::panic::catch_unwind 和 UnwindSafe trait，允许在一定场景下捕获恐慌以保护不变量。但这些机制使用复杂、适用范围有限，难以完全杜绝因恐慌引起的内存安全风险。因此，在理论上研究如何对恐慌情况下的 unsafe 代码行为进行分类和建模，在工程上制定相应的防范和分析方法，具有重要意义。

再次，恐慌跨越 FFI 边界（Foreign Function Interface, 外部函数接口）也是一个容易被忽视但危险的领域。Rust 程序经常需要与其它语言（尤其是 C/C++）交互，当 Rust 代码通过 FFI 被调用或调用他语代码时，如果发生 panic 会产生跨语言的异常传播问题。Rust 参考手册明确规定：如果不使用适当的 “C-unwind” ABI，直接让 panic 跨越例如 extern "C" 这样的 FFI 边界是未定义行为。也就是说，若 Rust 函数发生 panic 且未被捕获就越过 FFI 传递给调用的 C 代码，结果是无法预测的：可能导致进程直接终止，甚至内存破坏。从实践看，较新的 Rust 版本在检测到 panic 试图穿过 extern "C" 边界时，会直接触发 abort 以避免更严重后果，但这仍然意味着程序非正常终止，资源可能来不及释放，造成数据丢失或内存泄漏。另一方面，如果他语言的异常传播进 Rust（例如 C++ 异常进入 Rust 代码），同样会导致 Rust 运行时无法正常处理而中止或异常返回。由于 Rust 没有内建针对 FFI 异常的统一解决方案，开发者必须自行在边界处捕获处理 panic。例如，常见做法是在 Rust 外层用 catch_unwind 捕获 panic 并转换为错误码返回，这增加了编程负担和出错可能性。由此可见，在涉及 FFI 交互的场景下，Rust 恐慌机制处理不当会破坏原本隔离的内存安全边界，引发跨语言的安全漏洞。因此，研究 Rust 恐慌在 FFI 场景下的安全影响，以及如何静态或动态分析其中风险，对于保障基于 Rust 的混合系统的健壮性意义重大。

综上所述，Rust 的错误处理机制在设计上吸收了异常模型的长处，同时通过 Result 类型避免了滥用异常的隐患。然而 Rust 的 panic 机制具有特殊性：它既不像传统异常那样在语言层面显式声明，又会自动触发资源清理动作，从而在 Drop、unsafe、FFI 等交汇处埋藏了内存安全风险。随着 Rust 被广泛应用于操作系统、区块链、网络服务器等安全关键领域，挖掘和消除这些 panic 相关的隐患变得愈发重要。事实上，近年一些研究工作已经揭示了 Rust 生态中存在相当数量的由于异常控制流引发的漏洞。例如，美国佐治亚理工学院开发的 Rust 静态分析工具 Rudra 扫描了整个 crates.io 生态，发现了 263 个此前未知的内存安全漏洞，并据此报告了数百个安全公告。其中相当一部分漏洞就属于恐慌安全漏洞，包括标准库和流行库中因 panic 导致的内存错误。这表明，在 Rust “安全乐观”的表象下，panic 相关的内存安全问题并未得到充分研究和解决。本研究的理论意义在于深化对 Rust 异常（panic）机制下内存安全问题的理解，完善安全编程模型；实际意义则在于为开发高可靠 Rust 软件提供指导，预防此类漏洞，并为工具开发者指明改进方向。总之，保障 Rust panic 场景下的内存安全既是对 Rust 安全承诺的必要补充，也对软件工程实践具有重要价值。

## 1.2 研究问题与挑战

尽管 Rust 在语言层面提供了一系列机制来减少内存安全漏洞，但如上所述，panic/unwind 场景下的内存安全问题仍然存在分析困难和工程挑战。针对这些问题的系统研究尚属起步阶段，现有方法面临以下主要挑战：

（1）路径建模难题：Rust 程序中的恐慌引入了复杂的非正常控制流，使得对代码执行路径的建模变得困难。在传统分析中，一个函数从入口到退出往往有有限的控制流路径；但在 Rust 中，几乎任何操作都可能潜在地产生 panic 导致提前退出（例如数组越界访问、整数溢出检查、显式调用 panic! 等）。这意味着除了正常路径外，还需考虑 panic 路径。一个函数可能在多个点发生 panic，并通过栈展开影响调用链上的每一层函数。对于静态分析而言，这相当于在通常控制流图（CFG）之外增加了一条异常边，从基本块任意位置跳出至函数结束。要精确刻画 panic 传播路径，分析工具需要在函数和线程边界构建出带有异常分支的控制流模型。这涉及跨过程的数据流跟踪和状态保持。例如，当一个函数调用另外一个可能 panic 的函数时，既要分析调用成功返回的情形，也要分析被 panic 中断的情形。如何有效表达这种“双轨”执行流，以捕捉 panic 导致的状态变化，是建模上的首要难点。此外，panic 展开过程涉及调用各层的析构函数，其行为相当于在异常路径中插入了额外的执行片段（即所有存活对象的 drop 方法调用）。模拟析构链的效果对于准确分析 panic 路径至关重要，但析构函数本身可能包含复杂逻辑甚至再次引发 panic（双重 panic 会直接 abort 终止）。因此，常规的路径枚举无法直接应用，需要引入专门的异常控制流表示和状态跟踪方法。这大大增加了分析的复杂性和计算开销，也是目前许多 Rust 分析工具尚未很好覆盖 panic 相关漏洞的原因之一。

（2）分类语义薄弱：目前业界和学术界对 Rust 内存安全漏洞的分类主要侧重于一般的漏洞类型（如空悬指针、数据竞争、使用已释放内存等），对于由异常控制流引发的问题缺乏细致的分类语义。在 C++ 领域，有明确的异常安全等级划分（如基本保证、强保证等）指导开发者编写异常安全代码。然而 Rust 尚未形成类似统一的分类体系。Rust 官方仅通过 UnwindSafe/RefUnwindSafe 等标记 trait 粗略地区分了一些类型在跨 panic 时的安全属性，但这些机制主要用于 panic 捕获的安全边界判断，并不足以描述底层内存安全影响。近期有研究工作（如 Rudra）开始尝试对 Unsafe Rust 中的 bug 模式进行归类，总结出**“恐慌安全”（Panic Safety）**这一类别。该类别指代“由于恐慌导致的内存安全 Bug”，这是一个有益的开端。然而，这一定义本身仍相当宽泛，内部可能涵盖多种不同成因和表现形式的漏洞。例如，因 panic 导致双重释放属于一类，因 panic 导致未初始化内存泄露又是另一类；panic 跨越 FFI 导致未定义行为可以算作第三类。这些子类之间的区别、共性和危害程度，目前缺少统一的阐释和语义模型。此外，“恐慌安全漏洞”如何精确定义也是挑战。例如是限定在发生未定义行为（memory corruption）才算漏洞，还是包括逻辑错误（如资源泄露）？不同研究对漏洞的判定标准不尽相同。分类语义的模糊会直接影响分析工具的检测规则制定和结果解释。因此，迫切需要建立一套完善的分类体系，将 Rust panic/unwind 相关的内存安全问题进行细分类别定义，每类的触发条件、影响和判定标准都加以明确。这不仅有助于理论分析，更能指导实际工具设计，让检测覆盖全面且减少误报漏报。

（3）工具支持有限：目前针对 Rust 内存安全的自动化分析工具仍处于发展阶段，对 panic 相关问题的支持尤其不足。Rust 编译器自身（rustc）在编译期主要检查借用和生命周期，一旦代码通过编译，其运行期行为（包括 panic 路径）基本不在编译器强制检查范围内。标准的静态检查工具如 Clippy 提供了一些代码风格和可能错误的提示，但对复杂的 panic 安全问题无能为力。动态检测方面，Rust 提供了 Miri 等解释器工具，可以在运行时执行字节码并捕捉未定义行为。但 Miri 要求提供具体的测试输入去触发 panic 路径，而且在面对庞大的 crate 生态时难以大规模应用。真正专门面向 Rust 内存安全漏洞的工具以学术研究为主，如 Rudra、Linter GP 等。Rudra 作为静态分析工具，运用了一系列数据流和类型分析算法，成功发现了大量未知漏洞。然而，Rudra 聚焦的三大 Bug 模式中，除了“恐慌安全”以外，还有高阶不变式和 Send/Sync 问题。对于恐慌安全漏洞，Rudra 能检测出一些典型模式（例如前述的 String::retain 问题），但难以保证覆盖所有 panic 场景。此外，Rudra 等工具依赖于特定 Rust 编译器内部表示（HIR/MIR）的算法，对语言新特性和复杂代码可能出现漏报。同时，这些工具尚未整合进主流开发流程，需要特殊环境运行，使用门槛较高。总的来说，当下缺乏成熟的、广泛适用的工具来辅助开发者发现和避免 panic 相关的内存安全隐患。即使在研究社区，关于 panic 安全的分析技术也远不如常规内存安全（如漏洞挖掘、模糊测试）那样丰富。工具支持的匮乏使得许多 panic 导致的问题可能长期潜伏在代码中，无法及时被发现修复。这也是为什么构建针对 panic 安全的分析框架，评估和提升工具能力是一个极具价值的研究方向。

（4）版本依赖严重：Rust 生态发展迅速，编译器版本和库版本的迭代频繁，这给静态分析工具和安全研究带来了额外挑战。首先，大多数现有 Rust 静态分析工具都构建在 rustc 的不稳定内部 API 之上（rustc_private），这意味着工具本身必须与特定编译器版本紧密绑定。一旦 Rust 版本升级，内部数据结构或接口发生变动，分析工具就可能失效或报告大量误差，需要相应更新。实际经验表明，一些开源的 Rust 分析工具要求使用特定旧的 nightly 编译器才能运行，与现代 Rust 项目依赖的版本不兼容。开发者若想在自己的工程中使用这些工具，不得不调整项目的 Rust 版本或依赖项以迎合工具需求，这既繁琐又不切实际。其次，Rust 库（crate）本身也存在版本依赖问题：某些 panic 相关漏洞可能只在特定版本的库中出现，而被修复于后续版本。因此，研究者在收集和分析漏洞时，需要考虑同一库不同版本的行为差异。例如，一个漏洞或许在旧版本 std 库中存在，但新版本通过改动实现已无此漏洞。工具如果不识别版本差异，可能会对新版代码错误地报警（产生误报）或者漏掉老版本中的问题。再次，Rust 语言本身对 panic 机制的策略也在演进。例如，panic 策略（unwind 或 abort）在编译目标和版本之间有所不同，新版编译器甚至改进了 panic 跨 FFI 边界的处理（将 UB 转为 abort，以提高安全性）。这些变化都意味着分析必须跟上语言演化，否则可能基于过时假设。对于研究者而言，这增加了工作量和复杂度，需要投入更多精力维护工具和规则库。版本依赖严重的问题提醒我们：panic 安全分析框架需要具备灵活适应不同 Rust 版本的能力，或尽可能基于稳定的中间表示，以降低对具体编译器版本的耦合。同时，在评估现有工具能力时，也要考虑它们针对不同版本的有效性，找出共性的问题而非一时的版本缺陷。

综上，Rust panic/unwind 场景下的内存安全分析面临多重挑战：既有源于技术层面的路径爆炸和模型刻画难题，又有概念层面的分类定义不清，也受到现实环境中工具匮乏和版本演进的制约。这些挑战相互交织，使得简单套用已有的方法不足以全面解决问题。本研究正是针对上述困难，试图提出系统性的解决方案和研究框架，以推进 Rust 恐慌安全性的保障工作。

## 1.3 研究目标与研究内容

针对上述背景与挑战，本文的研究目标是在深入剖析 Rust 恐慌机制内存安全问题的基础上，提出有效的方法来分类、检测和评估此类问题，从而提升 Rust 生态的安全性。具体来说，本研究力求达到以下目标：

第一，建立 Rust 异常控制流相关内存安全漏洞的分类体系。我们将全面梳理 Rust 生态中已知的由于 panic/unwind 引发的漏洞案例和模式，借鉴异常安全理论和 Rust 内存模型，提出一套清晰的分类标准。该体系将精确定义各类恐慌安全漏洞的成因、条件和表现，包括但不限于：因 panic 导致的资源释放错误（如双重释放、释放顺序紊乱）、因 panic 导致的不变量破坏（未初始化数据被误用等）、panic 跨线程或 FFI 边界引发的未定义行为等等。通过形式化定义“安全值”（safe-value）集合和不变量条件等概念，我们为判定函数的 panic 安全性提供理论依据。分类体系的建立，有助于澄清过去语义不明确的问题，为后续分析提供共同语言。例如，我们将明确区分“最小异常安全”（不违背内存安全）与“最大异常安全”（功能行为完全正确）在 Rust 环境下的含义，并聚焦前者作为漏洞判定标准。总之，此分类体系既覆盖已有文献提出的类别如 Panic Safety，又进一步细化拓展，为 Rust 异常相关漏洞提供系统且有层次的描述框架。

第二，构建面向 Rust panic 安全问题的评测分析框架。在分类体系指导下，我们设计并实现一个评测框架，用于对 Rust 代码中的 panic 安全问题进行静态分析和检测评估。该框架包含两个核心部分：（i）分析建模层：我们基于 Rust 编译器中间表示（如 MIR）构造增强的控制流图，将 panic/unwind 路径显式纳入模型。结合数据流分析，我们能够模拟 panic 发生时资源析构和状态演化过程，从而检查是否违反分类体系中定义的安全条件。（ii）基准测试集：我们收集整理一系列能够代表不同类型 panic 安全问题的代码样例，包括真实漏洞（从 RustSec 公告、CVE 中选取）和精心构造的合成案例。每个案例都归属分类体系中的某一类，并注释期望的分析结果。借助这些基准，我们可以验证分析的有效性和覆盖度。整个框架的实现充分考虑 Rust 语言特性和生态环境：例如对泛型、宏展开、异步/线程等可能影响 panic 传播的因素也作适当处理。通过该评测框架，我们既可以自动扫描目标代码库中的潜在 panic 安全漏洞，也可以评估现有工具在这方面的表现。框架将输出检测到的问题及其对应的漏洞类别，帮助开发者理解漏洞成因并定位代码位置。值得一提的是，我们设计框架时注重通用性和可扩展性，希望能够随着 Rust 版本升级和新漏洞类型出现而方便地更新规则，从而减轻版本依赖的影响。

第三，利用上述框架评估主流 Rust 静态分析工具的能力边界。我们选择当前具有代表性的 Rust 内存安全分析工具和方法（例如 Rudra 静态分析、Miri 动态检测、Rust 编译器内置的安全检查等），将它们应用于我们的测试基准与真实项目代码，系统评测其对各类 panic 安全问题的检测能力。通过实验数据，我们将比较不同工具在检出率、误报率、适用范围等方面的表现，分析它们各自的能力边界。例如，某些工具也许擅长发现典型的双重释放漏洞，但对 FFI 异常安全问题无能为力；又或者编译器的某项优化能否消除特定 panic 路径上的问题。我们还计划衡量不同 Rust 版本下工具的有效性变化，以体现版本依赖带来的影响。评估过程中，每当发现工具漏报某类漏洞，我们将深入剖析原因——可能是其分析模型未涵盖 panic 路径，也可能是其规则集缺少对应模式。基于这些发现，我们总结目前工具在 panic 安全分析上的能力上限，即哪些类型的问题基本可以被现有技术捕获，哪些仍然是盲区。同时，我们据此提出改进建议和未来工作方向。例如，如果发现 Rudra 对某类 panic 漏洞漏检率高，说明需要在静态分析中引入新的数据流检查；如果 Miri 能够检测出一些 panic 问题但受限于测试覆盖，那么将静态和动态方法相结合可能提高效果。通过能力边界的评估，本研究不仅验证了所提分类和框架的实用性，也为 Rust 社区后续开发更完善的分析工具提供了依据。

概而言之，本文的研究内容围绕“分类—建模—评估”三大模块展开：先有分类体系打基础，再有评测框架作工具，最终通过工具评估来验证和完善方法。这样的结构既确保了研究工作的系统性和完整性，又能产出多方面的成果：包括理论上的新分类标准、实践上的分析工具雏形、以及对现状的客观认识。我们的整体目标是填补 Rust panic 安全性研究的空白，为今后构建真正健壮的 Rust 软件和工具链提供借鉴。

## 1.4 创新点

围绕上述研究内容，本文凝练出以下主要创新点：

（1）面向异常控制流的漏洞分类与建模。本研究首次针对 Rust 语言，将以往零散的“panic 安全”问题提升到系统分类的高度，提出了异常/恐慌相关内存漏洞的分类体系。相比现有文献中对 “Panic Safety” 一语带过，我们的分类更为精细全面，明确区分了不同类型 panic 导致的安全风险及其判定标准。这一创新在理论上丰富了内存安全漏洞的类别维度，拓展了 Rust 安全模型，使其囊括非常规控制流带来的影响。此外，我们为各类漏洞建立了形式化的模型和不变量描述（例如利用类型安全值集合来定义何为“安全状态”），结合控制流语义给出了 panic 情况下程序行为的推理方法。这种漏洞建模方法填补了以往对异常安全定性描述的不足，达到定量分析的精细程度。简言之，我们不再将 panic 相关漏洞视作模糊的一类，而是能够对其发生机理进行严谨推演和分类验证。这一创新点为后续分析和工具实现奠定了扎实基础，在学术上具有新颖性和独创性。

（2）基于分类体系的静态分析能力边界评估框架。本文构建的评测框架并不仅是一个单纯的漏洞扫描器，更重要的是它肩负着评估静态分析能力边界的使命。这一框架创新性地将安全漏洞分类与工具评估相结合：我们利用分类体系指导测试用例生成和分析指标设计，从而能够有针对性地考察现有工具在各类别漏洞上的表现。与传统 Benchmark 不同，我们的框架突出分类覆盖度，保证每一种已知类型的 panic 安全问题都在评估范围之内。这使我们能够第一次清晰地描绘出现有 Rust 安全分析工具在异常控制流方面“能做到什么、不能做到什么”。这样的评估框架对研究社区和工业界都非常有价值：它为研究者衡量新工具改进提供了标尺，也为工业选择安全工具提供了科学依据。更进一步，我们在框架中引入了对不同编译器版本、不同项目类型的可配置支持，使之成为一个通用的平台。研究者可以持续往其中添加新的漏洞类型和测试用例，不断拓展评估维度；当 Rust 语言演进或新的工具出现时，也可将其纳入评估体系，实时更新能力边界图谱。可以说，我们所提出的是一个面向未来的评估框架，开创了 Rust 静态分析工具综合对比的新途径。这一创新点在实践中将帮助找出当前方法的盲区，从而激发后续技术突破，具有重要的引领意义。

（3）实践导向的补充创新点：除了上述两大核心创新外，本文在实践层面亦有所探索。我们设计并实现了一个原型静态分析工具插件，将分类体系中的检查规则融入 Rust 编译流程，作为对现有工具的有益补充。该原型利用编译器的 MIR 数据流分析接口，对函数可能的 panic 点和资源操作进行检查，能够在编译阶段发出警告提示潜在的 panic 安全隐患。这项工作证明了我们的分类体系和分析方法具有可落地性，可与 Rust 现有工具链集成，为开发者提供即时的反馈。尽管原型功能有限，但它体现了一种实践导向的思路：即学术研究产出可以快速转化为开发辅助工具，服务于一线 Rust 工程实践。与此同时，我们通过原型工具在若干真实开源 Rust 项目上进行测试，发现了少数此前未知的 panic 相关内存安全问题，并已将这些发现反馈给项目维护者。这一结果进一步验证了本研究的实用价值，展示了创新方法在实际代码中的有效性。总之，这一实践小创新点不仅强化了本文结论的说服力，也为业界提供了直接可用的成果。

## 1.5 论文结构安排

本文余下章节结构如下：第二章将综述 Rust 内存安全机制与异常安全理论基础，回顾国内外针对 Rust 漏洞分析的相关工作，为本文研究提供背景支持。第三章详细介绍我们提出的恐慌安全漏洞分类体系，包括分类标准的制定过程、各类别的定义与示例，以及形式化建模方法。随后，第四章阐述我们构建的评测框架的设计与实现，实现原理、关键技术细节以及基准测试集的构造方法，并给出框架在若干典型代码上的运行结果示例。第五章则聚焦实验评估，利用第四章的框架对现有 Rust 静态分析工具和方法进行能力边界测试与结果分析，比较不同工具对于各类 panic 安全问题的检测效果，讨论发现的问题和改进空间。最后，第六章总结全文，指出本研究的局限与展望未来的研究方向，包括进一步完善工具链、扩展分类体系到更广泛的异常情形等。通过上述章节的展开，本文希望全面呈现 Rust 恐慌安全性领域从理论分类到实证评估的一系列创新成果。
