# 第 4 章 Rust 非正常控制流内存安全问题的场景分类与机制分析

在现代内存安全研究中，如何对漏洞进行分类是奠定分析与防御体系的基础。Rust 语言提供了严格的编译期检查来保证内存安全，但在异常控制流（如运行时的 panic 异常、跨语言调用等）影响下，仍可能出现内存安全漏洞。本章针对 Rust 中因非正常控制流扰动而引发的内存安全问题，提出了一套场景化的分类体系，并深入分析各类场景的触发机制与内在原理。我们将首先阐述分类设计的动机与原则，然后给出场景分类框架，逐一讨论四类主要场景（S1–S4）的细节机制及典型后果，最后总结各场景与具体漏洞类型的映射关系并加以讨论。

## 4.1 分类动机与设计原则

直观来看，内存安全漏洞通常以 Use-After-Free (UAF)、double free、未初始化内存访问、内存泄漏等具体类型呈现。然而，我们选择不简单按照这些“表象”漏洞类型对 Rust 内存安全问题进行分类。这是因为同一种异常控制流触发场景往往可能表现出多种不同的漏洞症状，反之，不同机制引发的问题也可能在表面上呈现相同类型的漏洞。例如，`Drop` 析构函数中发生的 panic 既可能导致未释放资源被泄漏，又可能导致部分重复释放而形成 double free 或引发悬空引用 UAF。如果仅以“是否 UAF”、“是否 double free”等表象来分类，具有相同根源机制的问题将被割裂到不同类别中，反而掩盖了它们机制上的共性，不利于深入理解和系统防御。同样地，不同来源的异常如 panic、中断的 FFI 调用等，都可能表现为类似的 UAF 漏洞，但其诱因和过程大不相同。因此，我们更关注异常控制流触发的场景语义，按机制而非按症状对漏洞加以分类。

我们提出的分类遵循以下设计原则：
1.  **语义贴合性**：分类应反映异常控制流干扰程序内存管理的不同行为语义，使每类场景都有清晰直观的语义描述，便于开发者理解其发生情形；
2.  **可复现性**：每种场景应能够通过相对简洁的代码片段稳定复现，这既有助于我们验证分析，也方便后续基于这些场景设计测试用例来评估工具；
3.  **可评测性**：分类应服务于后续漏洞检测工具的评估，确保每类场景都可以被现有分析方法识别或被设计针对性测试，从而发现工具的覆盖盲区；
4.  **贴近真实漏洞**：场景划分应能够映射到真实世界中已发生的漏洞模式，证明这些场景不仅是理论构造，而且在实际 Rust 项目中确实出现过，从而保证分类的实用价值。

基于以上原则，我们没有采用简单的表征型分类，而是围绕异常控制流对资源生命周期影响的典型场景来进行划分。

## 4.2 场景化分类的总体框架

在分析大量 Rust 内存安全案例时我们发现，可以从触发点、资源状态、边界位置三个维度来刻画异常控制流相关问题的发生情境。

*   **触发点位置**：即 panic 或其它非正常控制流发生在何处：是在普通函数执行过程中、对象的析构（`Drop`）过程中、自定义的资源清理逻辑中，亦或跨越语言边界（FFI）时发生。触发点不同，程序所处的上下文也不同，影响后续资源处理的方式。
*   **资源状态维度**：指异常发生时相关资源所处的内存生命周期状态。例如，资源可能尚未完全初始化就遭遇 panic，或者正处于部分释放/已释放状态，又或者正被多个别名引用共享，甚至由程序员手工管理其生命周期。
*   **边界位置**：即异常控制流是否跨越了安全/不安全代码边界、跨越了 crate 模块边界，或跨越了 Rust 与外部语言（例如 C）的 FFI 边界。这关系到编译器和运行时对异常的处理方式，以及两侧对于资源所有权和清理责任的约定。

基于以上维度，我们将 Rust 异常控制流引发的内存安全问题归纳为四类场景（S1–S4）。
*   **场景 S1（析构过程中 panic）**：触发点在对象的 `Drop` 实现内部。此时资源可能正处于部分释放或即将被释放的状态，panic 会中断正常的析构链。边界方面，一般发生在 Rust 安全代码调用的不安全析构逻辑交界处。
*   **场景 S2（未初始化或部分初始化时 panic）**：触发点在构造或初始化函数过程中。相关资源处于未完全初始化状态（例如使用 `MaybeUninit` 或尚未正确设置长度的容器）。panic 发生在安全/不安全交界处，例如 safe 代码调用了不安全代码进行手动内存操作的过程中。
*   **场景 S3（panic 跨越 FFI 边界）**：触发点涉及跨语言调用，即 Rust 函数通过 `extern "C"` 调用 C（或反之）时发生 panic。资源可能在 Rust 和 C 之间所有权交接状态。边界即 Rust 和外部语言的 FFI 接口，属于语言边界上的异常传播。
*   **场景 S4（自定义资源清理逻辑中 panic）**：触发点在手写的资源管理代码中（非标准 `Drop`），例如用户实现的作用域守卫或内存分配器逻辑。此时资源通常由程序员手工维护生命周期（可能已经调用部分自定义 `free` 操作）。边界位置往往在 Rust 安全代码与底层 `unsafe` 操作（如直接调用系统 `free` 或其他底层接口）的交界。

图 4-1 概括了本章提出的分类框架（此处略）。上述场景维度提供了分析异常控制流影响内存安全的视角。以下小节将按照 S1–S4 依次展开讨论。

## 4.3 场景 S1：Drop 执行中途发生 panic

### 触发机制
场景 S1 指的是对象析构过程中发生 panic 的情形。也就是说，当 Rust 的 `Drop` 实现还未执行完毕就被 panic 中断。这种情况可能由多种原因引起，例如：在 `drop` 方法内部显式调用了 `panic!`，或调用了可能触发 panic 的操作（如对 slice 索引越界、对 `Option` 调用 `unwrap` 失败等）而未加以防范。此外，一些外部库可能在析构时执行复杂逻辑，意外地引发 panic。如果在 `Drop` 的实现中调用了不受控的外部函数或包含手动的 panic 检查，也可能导致 panic 发生。

在安全实践中，通常建议不要在析构函数中 panic。原因在于，若析构发生 panic，而此时程序已经处在另一个 panic 的栈展开过程中，则会触发双重 panic 从而立即终止程序（类似于 C++ 中析构抛异常触发 `std::terminate`）。即使析构 panic 发生时没有其他未处理的 panic，启动新的栈展开也会中止当前对象后续字段的正常析构过程，转而直接展开到上层代码，这被形象地称为“析构链条中断”。

### 机制分析
当 `Drop` 中途 panic 时，对象所占用的资源可能处于半析构（half-dropped）状态。具体来说，有两种典型情况：
1.  **部分资源泄漏**：如果 panic 发生在释放某些成员之前，那么那些成员将永远得不到释放——因为整个析构过程被中断，后续资源清理逻辑不再执行，导致内存或其它资源泄露。
2.  **重复释放或悬空引用**：如果 panic 发生在已经释放了一部分资源之后，那么由于 panic 导致函数异常退出，当前对象并未完全摧毁，但其中一部分内容事实上已被释放掉。随后，当栈展开过程继续销毁其它对象或再次尝试销毁该对象时，就可能对这些已释放资源执行重复释放，或访问无效内存产生悬空引用。

例如，一个对象的 `drop` 实现先释放内部缓冲区内存，然后进行某些检查时 panic，那么缓冲区已被释放，但对象本身未完成析构。若该对象随后因为作用域退出再次尝试析构，或其所有权转移路径导致双重析构，则会发生 double free 或 Use-After-Free（UAF）。相关文档中描述了这种情况：线程在 unwind 过程中运行各对象析构，如果某个 `Drop::drop` 再次 panic，将立即导致程序 abort。此外，即使不发生双重 panic 导致的立即 abort，panic 中断也会使同一作用域中尚未析构的其他变量跳过正常析构，从而可能污染程序状态。

S1 场景下漏洞出现的前提通常是：析构函数本身包含了不安全行为或资源管理，需要它顺序执行才能保证安全。一旦被 panic 打断，原本假定的顺序被破坏。典型例子之一是利用 Rust 的 `unsafe` 操作绕过编译器检查，在对象析构时人为地复制出第二份资源所有权，导致双重析构问题。如下面简化的案例：假设有类型包含一个 `String`，其 `Drop` 实现中通过 `std::ptr::read` 不安全地读取出这个 `String` 副本，然后调用用户提供的闭包对副本进行操作（可能 panic）。正常情况下，为避免双重释放，原对象中的 `String` 应在闭包返回后使用 `mem::forget` 跳过 drop。然而如果闭包执行过程中 panic，则 `forget` 语句不会执行，结果原对象的 `String` 没有被忘却。当栈展开时，原对象和先前通过 `ptr::read` 复制出的副本都会各自执行一次析构，导致同一底层字符串缓冲被释放两次，形成 double free 漏洞。

### 典型后果
S1 场景体现出：析构函数内部的 panic 使对象未能完成正常的生命周期终结，进而诱发内存安全问题。常见后果包括：
*   **Double Free**：由于析构中断导致同一块内存被意外释放两次。
*   **悬空指针/UAF**：内存提前释放但后续仍有访问。
*   **资源泄漏**：应释放的资源未释放。
*   **进程 Abort**：若 panic 发生时正有另一 panic 在展开，则立刻触发进程 abort。

## 4.4 场景 S2：未初始化或部分初始化状态下 panic 中断

### 触发机制
场景 S2 是指程序在初始化资源尚未完成的中间状态遭遇 panic。典型情形包括：
*   使用 `std::mem::MaybeUninit` 手动逐步初始化复杂数据结构时，如果尚有成员未初始化就 panic；
*   使用低级操作如 `Vec::set_len`、`Vec::from_raw_parts` 手动调整容器长度或构造对象，在不满足安全前提下 panic 发生；
*   容器在扩容或拷贝元素的过程中，如果元素类型的 `Clone`/`Copy` 实现抛出 panic，导致复制过程半途而废。

### 机制分析
在 Rust 的严格内存安全模型下，正常情况下一个对象要么完全初始化好，要么完全未初始化。然而在 `unsafe` 代码块中，程序员可以暂时“欺骗”编译器，例如使用 `MaybeUninit<T>`。只要过程顺利完成且遵循正确顺序，不变量就能建立。可是一旦中途发生 panic，未初始化的内存可能被提前“曝光”给 Rust 的正常析构逻辑。

其一，**对象不变式尚未建立即进入析构**。以 `Vec::push_all` 的不安全实现为例：实现先调用 `reserve` 确保容量足够，然后直接使用 `set_len` 增加 `Vec` 长度，并通过指针操作逐个 `write` 新元素到位。然而潜在的问题在于，`set_len` 使 `Vec` 的长度立即包含了所有新元素的位置，但此时这些位置可能尚未真正写入有效元素。如果 `write` 元素的过程中 `T::clone` 方法 panic 了，函数会提前退出，而此时 `Vec` 的长度已经标记为比实际初始化的元素数更多。后续栈展开过程中对 `Vec` 进行析构时，会认为那些“虚假存在”的元素也是有效元素，从而对未初始化内存执行 drop。

其二，**部分初始化的数据结构在 panic 后被错误释放**。例如用 `MaybeUninit` 创建一个对象数组，然后逐个元素初始化。当完成一半时突然 panic，Rust 会在展开时尝试去 drop 已经初始化了的那些元素。但数组整体可能被认为已经构造，从而对未初始化的剩余元素也执行 drop。这将导致对未初始化内存调用对象的析构代码，释放未分配内存或者造成任意 UB。

### 典型后果
S2 场景的直接后果包括对未初始化内存的读取/引用、释放未初始化或未曾分配的内存，以及由此衍生的 Use-After-Free。这些行为都属于未定义行为，可能导致程序崩溃或数据破坏。例如，CVE-2019-16140 等漏洞的根本原因与此类似。

## 4.5 场景 S3：panic 跨越 FFI 边界传播

### 触发机制
场景 S3 涉及跨语言边界的异常传播。主要有两种触发情况：
1.  Rust 提供给 C 语言代码的回调函数在被调用时发生 panic，并试图越过 FFI 边界回传到 C 层；
2.  Rust 代码调用 C 函数期间发生 panic，导致异常跨越了原本的调用边界。

按照 Rust 的 ABI 规定，`extern "C"` 等非 Rust ABI 的函数接口默认被认为不会传播异常。如果 panic 试图跨越 FFI 边界，通常是未定义行为。

### 机制分析
C 代码并不知道 Rust panic 的存在，不会执行相应的清理逻辑。如果 panic 长驱直入进入 C 层，可能导致 undefined behavior。正因如此，Rust 对此有防御：在大多数情况下，如果检测到 panic 将越过 FFI 边界，Rust 选择直接 **中止(abort)** 程序。

但在某些特殊场景下，panic 跨 FFI 未被及时 abort，或者造成了资源不匹配释放的问题。例如：

```rust
let p = Box::into_raw(Box::new(100));  // 分配内存给C使用
unsafe { extern_c_call(p); }          // 调用C函数，约定C会处理p
do_something_after();                 // C返回后本应执行其它操作
```

如果 `extern_c_call` 在 C 层内部又调用了 Rust 的回调，而该回调 panic，则此 panic 将沿调用栈回溯。如果 Rust 未捕获此 panic，它将跨越 FFI 到达我们的 Rust 代码调用点。如果直接 abort，`do_something_after()` 相关的清理逻辑将被跳过，导致 `p` 指向的内存泄漏。如果 panic 被错误传播（如 `longjmp`），可能导致更复杂的资源不一致。

### 典型后果
S3 场景的后果要么是程序异常崩溃（大部分情况 Rust 直接 abort），要么是资源的不一致状态（泄漏或重复释放）。程序提前终止虽不是传统“漏洞”，但在安全上下文中意味着可用性缺陷。Double free 或 UAF 在这种场景下相对少见，但如果异常跨越被粗暴截获，可能会出现。

## 4.6 场景 S4：自定义资源清理逻辑中 panic

### 触发机制
场景 S4 指发生在自定义的资源管理或清理逻辑中的 panic 干扰。这里的清理并非通过常规的 `Drop::drop` 隐式进行，而是由程序员以定制方式执行，例如使用作用域守卫（scope guard）或自定义内存分配器。

典型的代码形态是：
```rust
let mut guard = create_guard(resource); // 创建作用域守卫，持有resource，Drop实现会释放resource
// ... 一些操作
guard.release_manually(); // 提供一个方法提前释放resource并标记guard已清理
// ... 释放后又发生panic ...
```

### 机制分析
核心问题在于手工管理的资源生命周期与 Rust 自动管理机制交织。在上述结构下，如果在 `guard.release_manually()` 成功释放底层资源后又发生 panic，而 panic 被向上传播，那么栈展开过程中 `guard` 的 `Drop` 仍会被调用。如果 `release_manually()` 中的标记操作（如 `mem::forget`）未能在 panic 前生效，或者 `Drop` 实现未正确检查标记，就会导致数据被再次 drop，即 **double drop**。

Rust 文档中提到：“如果 panic 发生在调用 `mem::forget` 之前，我们可能会丢弃掉无效的数据，或者执行双重丢弃（double-dropping）。”手动维护的资源生命周期步骤需要原子性，而 panic 正是破坏原子性的因素，导致资源管理操作执行了一半。

### 典型后果
S4 场景最主要的后果是 **Double Free** 或 **Use-After-Free**。
*   **Double Free**：panic 使得同一资源被手动释放一次，随后又在自动析构中释放一次。
*   **Use-After-Free**：如果在手动释放后又有代码尝试访问那个 resource，且 panic 导致控制流异常，可能会发生悬空引用使用。
*   **内存泄漏**：出于异常安全考虑，开发者可能宁可在 panic 情况下泄漏资源（例如使用 `ManuallyDrop`），也不冒险二次释放。

## 4.7 场景与漏洞类型映射及讨论

综上所述，S1–S4 四种场景分别描述了异常控制流影响内存安全的不同机制。表 4-1 给出了一个概览，将前文讨论的场景与典型漏洞表象进行对应：

**表 4-1 不同异常控制流场景下可能出现的漏洞类型映射**

| 场景 | Use-After-Free | Double Free | 未初始化内存访问 | 内存泄漏 | FFI相关 UB |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **S1 析构中panic** | ✓ 可能（如对象部分drop后仍被访问） | ✓ 常见（panic中断导致同资源drop两次） | △ 潜在（状态污染下可能读到无效数据） | ✓ 可能（panic跳过后续drop） | × 无直接FFI影响 |
| **S2 部分初始化panic** | ✓ 可能（释放未初始化内存后再访问） | ✓ 可能（同一内存块由两个对象分别释放） | ✓ 常见（未完全初始化的数据被读取） | △ 潜在（panic时已分配内存未正确释放） | × 无直接FFI影响 |
| **S3 跨FFI panic** | △ 间接（资源释放次序混乱可致UAF） | △ 间接（Rust/C双方均释放同一资源） | × 不涉及 | ✓ 可能（异常跳过释放步骤） | ✓ 常见（未定义行为或程序abort） |
| **S4 手工清理panic** | ✓ 可能（提早free后panic造成悬空引用） | ✓ 常见（panic导致手动释放+自动drop双重释放） | △ 潜在（手工过程数据不一致） | ✓ 可能（出于安全泄漏资源以防更坏情况） | × 无直接FFI影响 |

> 注：“✓”表示高概率关联，“△”表示可能/取决于情形，“×”表示一般不直接导致

从表 4-1 可以看出，S1 最突出的是 double free 和 UAF；S2 直接关联未初始化内存访问；S3 以 FFI 相关的 UB 和资源泄漏为主；S4 高度容易产生 double free。

将这些场景映射回真实案例，可以发现许多已公开的 Rust 安全漏洞往往是上述场景的具体体现。例如，`Vec::from_raw_parts` 的不当使用导致内存安全问题对应 S2 类别；FFI 接口函数未使用 `catch_unwind` 对应 S3。

从检测角度来看，静态分析工具如果没有模拟 panic 控制流，往往对 S1 和 S2 场景无能为力。S3 场景的检测更多依赖代码审计。S4 场景虽然通常出现在 unsafe 代码中，但跨越函数边界的复杂性增大了分析难度。

## 4.8 本章小结

本章提出了针对 Rust 中因 panic 等异常控制流引发的内存安全问题的场景化分类体系。我们首先阐明了分类的必要性：与其按 UAF、double free 等症状划分，不如按导致这些症状的异常机制划分，以更准确地反映问题实质。接着，我们从触发点、资源状态、边界位置三个维度构建了分类框架，确定了四大典型场景 S1–S4，并逐一分析了每种场景的触发机制和深层机理。
*   S1 聚焦于析构函数中的 panic 如何中断资源释放链条；
*   S2 解释了 panic 发生于对象部分初始化时如何导致未初始化内存被错误使用；
*   S3 讨论了 panic 跨越 FFI 边界带来的风险；
*   S4 揭示了 panic 干扰手工资源清理逻辑时的问题。

通过这些分析，我们将异常控制流相关漏洞与传统分类的漏洞类型进行了映射。本章的分类体系和机制解析为后续章节的工具检测与实验评估提供了基础依据。
