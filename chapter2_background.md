# 第二章 相关背景与技术基础

## 2.1 Rust 内存安全模型与资源管理

Rust 是一门以内存安全为核心目标的系统级编程语言，在设计上摒弃了垃圾回收器，转而依靠编译期的严格规则来保障内存安全和资源管理。其中，所有权（Ownership）、借用（Borrowing）和生命周期（Lifetime）是 Rust 内存安全模型的三大基础支柱，这些语义通过编译器的静态检查确保了内存的安全使用，并实现资源的自动回收。

所有权模型：Rust 引入了所有权的概念，即每个值在任一时刻有且仅有一个所有者。当所有者（变量）离开其作用域时，该值所占用的内存将自动释放（调用其析构函数）。所有权在赋值或函数传参时可以转移（move 语义）；一旦所有权转移，原来的变量便不再持有该值，任何对此原变量的访问都会被编译器视为错误。例如，当一个堆分配的字符串赋给新变量后，旧变量即失去所有权，后续使用旧变量将被编译器禁止，从而避免出现悬空引用或重复释放内存的情况。这种所有权一次性转移的规则配合编译期检查，彻底杜绝了传统 C/C++ 中由于手动管理内存而常见的“双重释放”等错误。换言之，Rust 使用线性/仿射类型系统追踪每个值的所有权，使得每块内存最多只会被释放一次。

借用与生命周期：在所有权模型之上，Rust 通过借用机制允许安全地引用已拥有的值，从而避免频繁地拷贝或转移所有权。借用分为不可变借用（共享引用，&T）和可变借用（独占引用，&mut T），其核心规则可概括为“可变性与别名互斥”（Mutability XOR Aliasing）。具体而言，在任一时刻，同一块数据要么只能被一个可变引用所借用并可修改，要么可以被任意多个不可变引用所借用但只能读取，二者不可以同时存在。这一规则在编译期由借用检查器强制确保：如果代码中出现违反规则的借用（例如同时存在对同一变量的可变借用和不可变借用），编译器将报错拒绝编译。这种机制防止了数据竞争和迭代器无效等并发访问问题，同时也避免了悬空指针——因为编译器还会跟踪引用的生命周期，确保引用的有效范围不长于其指向的对象的存活时间。例如，Rust 会禁止返回一个指向局部变量的引用，因为局部变量在函数返回时被销毁，其引用将成为悬空引用。通过在类型系统中引入显式的生命周期参数 'a 等，编译器能够静态地保证引用不超过其所依赖数据的生命周期。借用和生命周期机制使得 Rust 即便在没有垃圾回收的情况下，也能在编译期防止空悬指针的产生，确保内存访问的有效性。

资源自动析构与 Drop：Rust 采用 RAII（Resource Acquisition Is Initialization）习惯用法来管理资源，这与 C++ 的作用域资源管理理念类似。当变量离开作用域时，Rust 会自动调用该变量所属类型的析构函数（即实现了 Drop 特性的 drop 方法）以释放资源。Drop 特性定义了当值不再被使用时应执行的清理逻辑，包括释放内存、关闭文件、释放锁等。编译器在适当的位置插入对析构函数的调用，因此程序员无需手动管理作用域结束时的资源释放。例如，File 类型在实现了 Drop 后会在超出作用域时自动关闭文件描述符；又如使用智能指针 Box 分配的堆内存也会在离开作用域时自动释放。这种机制确保了资源分配和释放的严格配对，避免了资源泄漏。值得注意的是，Rust 对析构顺序有明确规定：当多个变量在同一作用域结束时，局部变量按照其创建的相反顺序被销毁，而结构体的字段则按照声明顺序逐一销毁。这样的析构顺序保证了复杂对象中各部分的依赖可以被正确处理。此外，Rust 编译器还会插入适当的“drop glue”以递归地销毁复合类型的所有字段。这一切均在编译期静态确定，使得程序在运行时能可靠地执行清理，而不发生诸如悬空引用或重复释放的问题。

unsafe 语义与编译器检查边界：为了在保证内存安全的同时赋予程序员底层操作的能力，Rust 提供了 unsafe 关键字来开启一段不安全代码块。在安全 Rust 代码中，编译器的借用检查、所有权检查等规则始终严格执行，确保程序不存在未定义的内存行为。然而，在某些场景下（如调用底层操作系统接口、执行特定优化等），这些规则过于保守，会阻碍合法的程序逻辑。unsafe 代码块的引入正是为了让开发者在特定情况下暂时绕过部分编译器检查，以便执行编译器默认禁止的操作。需要强调的是，unsafe 并不会完全关闭 Rust 的安全检查机制：在 unsafe 块中，除非涉及以下特别许可的操作，Rust 仍然会执行诸如借用检查等常规检查。unsafe 所赋予的“五大超级能力”包括：解引用裸指针、调用 unsafe fn 函数或方法、访问或修改可变静态变量、实现 unsafe 特质，以及访问联合体（union）的字段。这些操作由于可能破坏内存安全，在安全 Rust 中被禁止，但在标记为 unsafe 的代码块中则允许执行。然而，Rust 对进入 unsafe 世界的开发者提出了更高要求——“unsafe 并不意味着不安全”：程序员必须自行确保在 unsafe 代码块中的操作是内存安全的，否则就可能引入和 C/C++ 中相同的内存错误（例如空指针解引用、数据竞争等）。因此，unsafe 实际上将内存安全性的证明责任从编译器转嫁给了程序员。Rust 社区倡导将不安全代码封装在安全抽象后，并将 unsafe 使用范围限制在最小必要范围，以便大部分代码仍能在编译期享受内存安全保障。通过安全抽象层，标准库和第三方库在内部充分利用 unsafe 来实现底层功能（如内存分配、线程同步等），但对外暴露的接口仍保持安全语义，从而既发挥了 unsafe 的威力又不牺牲整体上的内存安全约束。

## 2.2 Rust panic 机制与异常控制流

在 Rust 中，panic! 宏及相关机制用于应对程序执行中不可恢复的错误，即发生 panic 时程序会进入异常终止的流程。常见触发 panic 的情形包括显式调用 panic! 宏、数组访问越界、整数溢出（在调试配置下）以及对 Option 调用 unwrap 而该值为 None 等。例如，对长度为 3 的向量执行 v[99] 访问将立即导致运行时 panic。当 panic 发生时，Rust 默认采用与 C++ 异常类似的栈展开（stack unwinding）策略来处理：panic 会使当前线程停止正常的指令流，转而沿调用栈向上回溯，逐层清理栈帧。这一展开过程中，每退回到上一层函数调用，都会执行该层函数中尚未执行的析构操作，如释放局部变量和临时值的资源。换而言之，栈展开使 panic 的处理过程看起来像是各个调用的函数突然提前返回，且保证所有应执行的析构器（Drop）都被正确调用。这样，当线程因为 panic 而终止时，所有受影响的对象都已按正常流程销毁，确保内存不会泄漏，锁等同步原语也能及时释放。

需要注意的是，Rust 并非强制使用栈展开来处理 panic。出于性能和二进制体积的考虑，Rust 提供了 abort（终止）策略作为替代。当选择 panic = "abort" 时，程序在发生 panic 时将不进行展开，而是立即终止整个进程。这种策略跳过了所有清理工作，直接让操作系统接管程序资源。未执行的析构器所管理的内存会由操作系统回收，但像文件未刷新的缓冲区、临时文件等资源可能无法按逻辑释放。从而，abort 策略提高了运行时效率（避免了展开的开销）并减少了生成代码（无需包含展开所需的元数据和代码），但代价是程序无法继续执行，也无法保证非常态结束时的资源清理行为。开发者可根据需求通过编译选项或 Cargo 配置选择 panic 处理策略：大多数平台默认采用栈展开（以支持恢复），但在一些资源受限环境可以改用终止策略。例如，在 Cargo.toml 的 [profile] 中设置 panic = "abort" 可以切换为终止策略，从而减小生成的二进制文件大小。

无论采用何种策略，panic 的存在都会对程序的控制流产生重大影响。相比正常的函数返回或分支跳转，panic 引入了一条非常规的控制流路径：它可以在代码的任意点中断当前函数的执行，并在未显式标注的情况下跳转到栈上更高的异常处理点（如线程边界或显式捕获点）。这种不透明的控制流使得程序的执行路径难以静态预测，给程序分析和建模带来挑战。一方面，栈展开时执行的清理代码（析构函数调用）并不在函数的显式源代码序列中，而是由编译器插入的隐含流程，分析工具必须认识到这些隐式的控制流边缘。另一方面，如果不考虑 panic，函数看似不会中途返回，但实际运行时 panic 可导致函数半途退出，这意味着分析时需要在可能 panic 的操作处加上额外的控制流分支。例如，任何可能触发 panic 的调用（如索引、除零、unwrap 等）在底层 MIR 中都会存在一个对应的 “unwind” 分支，指向清理处理基本块，以确保在发生异常时执行内存回收和资源释放。如果分析模型忽略这些非常规路径，可能会错误地假设某些代码一定会被执行或某些资源一定会被释放，进而导致对程序行为的理解不完整甚至错误。因此，在对 Rust 程序进行静态分析或形式化建模时，必须将 panic 视为一种可能的控制流出口，并相应扩展控制流图以涵盖由 panic 引发的路径。总的来说，Rust 的 panic 机制提供了与异常相似的运行时错误处理方式：它在保证内存安全和自动清理的同时，也引入了异常控制流固有的复杂性，需要仔细建模才能确保程序分析的正确性和完备性。

## 2.3 Rust 中的 panic 安全性语义体系

panic 安全性（panic safety）是 Rust 提出的一个概念，用于描述程序在出现 panic 异常时对于资源状态和数据不变性的保障程度。这个概念与 C++ 的异常安全（exception safety）类似，关注的是当异常（对于 Rust 即 panic）发生并展开时，程序的数据是否仍保持一致，以及是否避免了未定义行为。Rust 从设计之初就要求，即使发生 panic，安全代码也不会导致内存安全性质被破坏——换言之，在不使用 unsafe 的前提下，panic 不会造成缓冲区溢出、悬空指针、数据竞争等底层内存错误，即使程序由于 panic 提前中断，其执行过的操作序列也应符合内存安全的规则。Rust 编译器在栈展开过程中调用所有必要的析构函数，确保分配的内存和资源不泄漏，这提供了类似 C++ “基本保证”（basic guarantee）的语义：即便出现异常，程序不会遗留下危及后续执行的垃圾状态，已获取的资源要么被正确释放要么仍可被安全回收。

然而，panic 除了内存安全之外还涉及更高层次的逻辑安全性或不变式安全性。所谓不变式安全性，是指数据结构即使在操作中途中止（如发生 panic）也不会遗留违反其抽象不变式的状态。例如，考虑一个表示账户转账的操作，如果在扣款后但未完成存款时 panic，就可能导致资金丢失或账户不平衡的逻辑错误。为应对这类问题，C++ 提出了异常安全的更高等级（如 strong guarantee 等），而在 Rust 中，则发展出 panic 安全性的语义体系来约束此类情形下的数据状态。Rust 标准库通过一些策略来应对 panic 导致的逻辑不一致，其中最典型的是**毒化（poisoning）**机制。例如，在多线程并发中，std::sync::Mutex 的实现会在持锁线程发生 panic 时将互斥锁标记为已中毒。这样当其他线程试图获取该锁时，可以检测到先前发生过 panic，从而选择提前失败而不是继续操作可能处于不一致状态的数据。通过毒化处理，Mutex 实际上维护了一个不变式：“如果共享数据可能已被不正常修改，则进一步的访问应被阻止或受到警告”，从而避免隐蔽的数据错误。正因如此，Mutex<T> 被视为是一种 panic 安全（或 unwind safe）的类型——它对 panic 做了防护，使得 panic 过后的共享状态不会被默默地当作正常状态使用。

为了在类型层面反映哪些类型在遇到 panic 时仍被视为安全，Rust 的标准库引入了两个标记性 trait：UnwindSafe 和 RefUnwindSafe。其中，UnwindSafe 表示将某个值转移（move）到另一个线程或通过闭包捕获并在 catch_unwind 后继续使用是被认为安全的；RefUnwindSafe 则表示通过共享引用（&T）访问时，该类型也是安全的。简单来说，如果一个类型实现了 UnwindSafe，意味着当线程在该类型的操作过程中发生 panic 并展开栈后，不会“轻易地”观察到其不变式被破坏。大部分普通类型都是 panic 安全的，因而 Rust 将 UnwindSafe 定义为自动实现（auto trait）：凡是编译器认为“不易出现不变式破坏”的类型都会默认实现该 trait。典型地，所有完全由 Safe Rust 代码组合而成的类型都自动是 UnwindSafe，除非其中包含了一些特殊内部可变性。相反，一些存在内部可变状态且可能在 panic 时中途被修改的类型则不自动实现 UnwindSafe。例如，&mut T（可变引用）不被视为 unwind safe，因为如果一个可变引用捕获到闭包中并在使用过程中发生 panic，闭包外持有该引用的一方可能无法察觉底层数据的不一致状态。又如 UnsafeCell/RefCell 等提供内部可变性的类型也被标记为 !UnwindSafe（不实现 UnwindSafe），原因在于它们允许即使只有不可变引用也能修改数据：如果 panic 在修改尚未完成时发生，后续读取可能观察到部分更新的数据，这违反了逻辑上的原子性。因此编译器保守地认为带有 UnsafeCell 成员的类型在 panic 后可能呈现不一致状态，从而不自动实现 UnwindSafe。相对应地，RefUnwindSafe 针对的是通过共享引用传递的数据，当一个类型内部包含 UnsafeCell 时，即使通过 &T 引用访问也可能出现隐藏的可变状态不一致，因此这类类型不实现 RefUnwindSafe。

需要指出的是，UnwindSafe/RefUnwindSafe 这些 trait 本身并非 unsafe，它们更类似一种编译期的提醒或约束，而非严格的内存安全保证。UnwindSafe 的作用主要在于当使用标准库提供的 std::panic::catch_unwind 捕获 panic 时，Rust 要求闭包捕获的环境中的类型必须实现 UnwindSafe，否则代码将无法编译。这相当于在可能恢复执行的边界处添加了一道“门闩”，提示开发者：某些捕获的数据也许在 panic 后处于不一致状态，继续使用需要谨慎。如果开发者确信特定情况下仍可以安全地恢复使用这些数据，可以利用 std::panic::AssertUnwindSafe 来强制声明捕获的数据是 unwind safe，从而绕过编译器的检查。这一设计初衷是在引入可恢复的 panic 捕获机制时提供额外的防护。早期的 Rust（1.0 之前）并未提供 catch_unwind，panic 只能由线程边界截获；后来随着 catch_unwind 的稳定，UnwindSafe 体系被加入以帮助标记类型的 panic 安全特性。不过在实践中，UnwindSafe 往往只是起警示作用，其产生的限制在多数情形下可以用 AssertUnwindSafe 绕过而不造成实际问题。正如有人指出的那样，如果代码在 panic 情况下仍保持内存安全，那么逻辑上的不变式问题也应当作为普通的逻辑 bug 加以修复，而不应通过简单地标记 trait 来掩盖。因此，Rust 更加强调的是内存层面的 panic 安全：安全 Rust 保证 panic 不致使程序进入未定义行为或破坏基本的资源回收逻辑，而对于更高层次的逻辑一致性，则需要库和程序自身通过设计来确保（例如借助事务性操作、毒化机制或文档约定）。总而言之，Rust 的 panic 安全语义体系确保了 panic 发生时程序内存安全和资源释放的可靠性，同时提供工具去帮助识别和避免逻辑层面的异常状态，但这部分更多倚赖于约定和模式而非强制的语言机制。

## 2.4 Rust 静态分析技术基础

静态分析是保障 Rust 代码可靠性的重要手段之一。而 Rust 之所以能够支持高精度的静态分析，与其编译器中间表示 MIR 的设计密切相关。**MIR（Mid-level Intermediate Representation）**是 Rust 编译器在抽象语法树（HIR）之后、生成机器代码（LLVM IR）之前使用的中层中间表示。MIR 将 Rust 代码转换为一种基于控制流图（CFG）的低级表示形式：在 MIR 中，没有复杂的嵌套语法结构，所有的控制流结构（如条件判断、循环、模式匹配）都被显式地展现为基本块和跳转。同样地，诸如自动引用/解引用、方法调用等高层语法糖也被展开成更基本的操作。这种去语法糖化（desugaring）的过程极大简化了程序结构，使 MIR 成为一种规范化的 Rust 程序表示，被誉为程序语义的“真实载体”。正如相关研究所指出：“在 MIR 中，不存在任何有趣的事情发生在单个节点内部”——也就是说，MIR 的每个基本块内的指令都非常原子化，控制流的细节被完全摊平，因而静态分析工具无需重复处理源代码中的复杂结构即可遍历程序的所有执行路径。此外，MIR 也是全类型化的（所有类型在 MIR 中都是具体且已确定的），这为静态分析提供了准确的类型信息支持。

一个关键的设计是：MIR 中显式地包含了资源清理和异常控制流的信息。Rust 编译器在构造 MIR 时，会将所有可能的 drop（析构）操作都明确地表示出来，包括正常作用域结束时的 drop，以及由于 panic 引发的异常退出所需执行的 drop。在 AST 或 HIR 层面，析构操作往往是隐式的，例如当变量离开作用域时是否调用析构函数并没有直接的语法节点表示，但在 MIR 中，每当一个变量的生命周期即将结束（不论是正常路径还是异常路径），都会插入相应的 drop 指令。这意味着，静态分析工具在 MIR 上可以轻易地识别出所有可能的资源释放点和释放顺序。特别地，对于可能发生 panic 的操作，编译器在 MIR 中增加了隐式的异常处理基本块（cleanup blocks）：一旦某个操作可能 panic，MIR 会包含一条通往清理块的 “unwind” 边，用于调用在该函数中尚未销毁的变量的析构函数。例如，调用某个可能 panic 的函数时，MIR Terminator 会有两个后继基本块：一个是正常返回的继续执行块，另一个是 panic 时的清理块，在其中编译器按正确顺序销毁当前函数已建立的局部变量。这种设计确保了 MIR 的控制流图是完整的、可达终点的，即使面对无限循环或 panic 等非常规控制流也不会丢失节点。对于静态分析而言，这提供了至关重要的精确性：分析工具能够在 MIR 上追踪到程序所有显式和隐式的执行路径，包括异常路径和清理路径，从而避免遗漏重要的状态变化或资源处理过程。

Rust 编译器本身的诸多静态检查和优化均基于 MIR 展开。例如，Rust 著名的借用检查（包括移动语义检查）最初在较高层的表示上实现，但后来迁移到了 MIR 上以利用其简化的控制流和完整的语义信息。MIR 提供的精确数据流语义也使其他数据流分析（如生命期分析、存活变量分析、死代码消除等）更为可靠。除了编译器内建的分析，研究者和工程师也利用 MIR 来构建各类静态分析和验证工具。Facebook 开源的 MIRAI 分析器即在 MIR 上执行抽象解释，以推断程序可能的运行时错误和性质；美国国家安全局的 Kani 则基于 MIR 做模型检验，将 Rust 程序转换为 SAT/SMT 问题验证特定性质；ETH Zurich 开发的 Prusti 项目则将 Rust MIR 提升为逻辑中间表示以进行程序的形式化验证。安全审计领域的工具如 Rudra 则对 Rust 仓库的大规模代码进行扫描，依赖 MIR 来发现不安全模式和漏洞。更有学者构建了通用的 Rust 静态分析框架（如 Charon），进一步简化了基于 MIR 进行分析的流程。这些工具之所以选择 MIR 作为基础，正是因为 MIR 在表达 Rust 语义时达到了一个很好的权衡：它足够低级以显式揭示所有细节（比如内存移动、借用、析构、模式匹配展开等），因而分析时不会错过复杂语言特性带来的影响；同时它又保持了程序结构的层次和可读性，相比直接分析编译后的机器码要容易得多。MIR 还在持续演进，例如“稳定 MIR”计划尝试提供一个稳定的 MIR 接口供外部工具使用，以免分析工具紧耦合于编译器内部实现细节。

总而言之，Rust 的 MIR 为静态分析提供了坚实的技术基础。通过 MIR，静态分析工具可以准确地建模 Rust 程序的控制流和资源生命周期，包括正常执行路径和由于 panic 导致的异常路径。这使得在 Rust 上实现诸如内存安全验证、逻辑错误检测、漏洞挖掘等静态分析成为可能且有效。再加上 Rust 本身的内存安全保障，静态分析人员在 MIR 层面所发现的问题，大多是真正可能在运行时发生的问题，而非误报或冗余。这种高度的信噪比也正是 Rust 被誉为“可验证编程语言”的原因之一：借助强大的类型系统和适宜的中间表示，Rust 既在语言层面减少了大量错误，又为更深入的程序静态分析铺平了道路。
