# 第三章 相关工作与评测对象

本章的目的在于介绍与本研究相关的现有工作，并确定后续评测所针对的分析工具对象。由于我们构建的评测框架需要基于现有工具的能力，因此有必要系统梳理当前具有代表性的 Rust 程序分析工具在 panic 安全问题上的支持情况。所谓 panic 安全问题，指的是程序在运行过程中发生 panic（类似于异常终止）时可能引发的内存安全隐患。Rust 语言通过所有权模型提供内存安全保障，但在 panic 引发栈展开（unwinding）时，封装的底层 unsafe 代码可能出现资源释放顺序紊乱，导致诸如未初始化数据使用、重复释放等内存安全漏洞。本章将介绍四种代表性的 Rust 静态分析工具（Rudra、MirChecker、SafeDrop、FFIChecker），分别阐述其分析原理、适用范围、针对 panic 相关安全问题的覆盖类型，以及各自模型中隐含或显式的假设。最后，我们对比这些工具在处理 panic 相关内存安全问题时的异同，为下一章评测指标的设计和样例集的构建提供基础支撑。

## Rudra

Rudra 是一款面向 Rust 语言的静态分析工具，旨在大规模检测 Rust unsafe 代码中的内存安全漏洞。该工具由 Georgia Tech 的研究团队开发，并发表于 SOSP 2021。Rudra 专注于发现 unsafe Rust 代码中可能破坏内存安全的常见模式，包括 panic 安全漏洞、高阶不变式违规以及不正确的线程安全标记等三类问题。其中，panic 安全漏洞是指在封装的 unsafe 代码中，如果发生 panic 导致异常退出，可能因为对象处于不一致状态而在销毁过程中引发未定义行为，例如重复释放或释放未初始化内存。这类漏洞类似于 C++ 的异常安全问题，在 Rust 中也被证实曾导致标准库和常用库中出现严重内存安全缺陷。Rudra 通过大规模扫描，曾在整个 Rust 生态（4.3 万多个 crate）中发现 264 个新的内存安全漏洞，涵盖上述三类模式，并由此触发了众多安全通告和补丁发布。

Rudra 的分析原理基于对 Rust 中间表示的静态数据流分析，结合启发式的污点传播（taint analysis）算法。具体而言，Rudra 首先提取 Rust 编译后的高层和中层 IR（HIR 和 MIR），重点分析被标记为 unsafe 的代码片段。它实现了一种不安全数据流检查（Unsafe Dataflow Checker）的算法，用于检测 panic 安全和高阶不变式问题。该算法将可能绕过生命周期检查的操作视为数据源（如创建未初始化变量、延长对象生命周期、原生指针转换等六大类操作），并追踪这些不安全操作产生的值流向函数调用等关键点。如果这些值经由数据流到达了“可疑”的函数调用处，Rudra 即认为可能存在漏洞。所谓可疑调用包括：可能发生 panic 的操作，或对调用者提供的高阶函数/闭包的调用。Rudra 的关键在于如何辨识潜在的 panic 发生点。为此，作者引入了不可解析泛型函数的概念，作为 panic 点的近似替代。凡是函数定义在编译时因缺少具体类型参数而无法解析实现（例如 trait 方法调用），Rudra 均 conservatively 假定其内部可能执行 panic 或依赖某种语义不变式。这种近似显式体现了 Rudra 的模型假设：在缺乏完整信息时，将未知的泛型调用视为最不利情况，从而捕获 panic 安全隐患和高阶不变式违规。这种策略提高了分析的覆盖面和速度，但也引入了一定程度的过报（false positives）。实际评估中，Rudra 报告的警告中约有 89% 属于误报或低优先级问题，需要人工筛查。为控制误报，Rudra 提供了精细度过滤机制，允许用户在高、中、低精度模式下运行，以平衡检测的敏感性与误报率。总体而言，Rudra 通过牺牲部分精确性，实现了对 Rust 全生态进行快速、全面扫描，在 panic 相关内存安全漏洞检出方面具有代表性意义。

Rudra 的适用范围主要是检测 Rust 开放源代码库中的 unsafe 代码隐患。它被实现为 Cargo 的子命令以及 Rust 编译器的自定义 lint 插件，能够方便地集成到 Rust 项目的构建过程中。由于 Rust 安全子集保证安全代码不存在未定义行为，Rudra 显式假定所有内存安全漏洞来源于 unsafe 代码片段，因此分析时仅聚焦 unsafe 代码的内部实现，并不深入检查安全代码逻辑。这种假设使 Rudra 能够忽略安全代码中纯粹会导致 panic 的条件（例如数组越界访问在安全 Rust 中只会触发运行时 panic 而非内存错误），将精力集中于 unsafe 代码可能导致的真正内存错误。这一设计与 Rust 语言“安全代码不犯错、错误发生于 unsafe”的理念一致，但也意味着 Rudra 不会报告纯安全代码中的 panic（如整数溢出）问题。综上，Rudra 在模型上采取了不完备但务实的近似：假定未解析的泛型调用可能 panic、假定 unsafe 之外代码是安全的，从而实现大规模内存漏洞检测。这一系列显式或隐式假设，奠定了 Rudra 在 panic 安全问题检测上的独特优势和局限——它能够发现诸如 panic 引发的双重释放、未初始化内存释放等隐患，但对非 unsafe 代码导致的崩溃并不关心，需要与其他工具结合以全面覆盖所有类别的问题。

## MirChecker

MirChecker 是香港中文大学等提出的一种 Rust 程序错误检测框架，采用静态分析技术在 Rust 编译中间表示（MIR）上检查程序中的潜在运行时错误和内存安全漏洞。该工具发表于 CCS 2021，与 Rudra 同期，是 Rust 静态分析领域的另一代表性工作。MirChecker 旨在补充 Rust 类型系统的不足，在程序部署前提前发现那些编译阶段无法捕获的错误。具体来说，Rust 编译器对某些运行时条件（例如数组越界、整数运算溢出）采取动态检查，一旦违反条件就触发 panic 中止程序，以避免内存破坏。然而对于安全要求极高的场景，任何运行时 panic 都是不可接受的（会导致服务拒绝或崩溃），因此 MirChecker 将此类运行时 panic 也视作待检测的“漏洞”类型之一。同时，MirChecker 关注内存安全漏洞，特别是由于所有权和生命周期管理不当导致的常见错误模式，例如解引用悬空指针、重复释放等。这些错误往往涉及 unsafe 代码对内存的直接操作，突破了编译器的静态检查。MirChecker 将这类问题归纳为生命周期篡改（lifetime corruption），通过跟踪堆内存的别名和所有权转移来检测。例如，对于经典的不安全函数 Vec::from_raw_parts，MirChecker 会监测其获取原始指针所有权的操作，并验证原始指针后续是否仍被使用，以发现潜在的 use-after-free 漏洞。

MirChecker 的分析方法建立在抽象解释（Abstract Interpretation）框架之上，结合数值分析和符号执行来实现对程序的精确静态模拟。在实现上，MirChecker 利用 Rust 编译器内部提供的 MIR 表示，对每个函数的控制流图进行符号执行般的遍历分析。分析过程维护两类抽象域：一是数值域，用于跟踪整数变量的取值范围（采用了 Apron 库实现的区间、多面体等多种数值抽象）；二是符号域，用于表示指针别名关系和条件表达式等符号信息（基于 Facebook 开发的 MIRAI 分析器）。MirChecker 迭代执行每条 MIR 语句的传输函数（transfer function），不断收敛各基本块的抽象状态，直至固定点，以枚举出程序的所有可达状态。随后，在错误检测阶段，工具会收集程序中的断言条件（例如数组边界检查所对应的 Assert(cond) 终止语句），将数值域和符号域的信息转化为约束求解问题，通过 SMT 求解器（Z3）验证这些条件的反面是否可满足。如果存在模型使断言条件失败，即证明程序存在使该断言触发 panic 的输入，MirChecker 则报出相应警告。同理，对于内存安全检查，MirChecker 依据预先收集的 unsafe 操作（如原生指针创建、内存释放函数等）来监控所有权是否被违规使用：一旦发现所有权转移后原所有者仍被访问，或者双重释放同一资源的路径，立即判定为漏洞并生成报告。

MirChecker 覆盖的 panic 安全问题类型包括：运行时 panic 漏洞（例如整数溢出、除零、数组越界导致的 panic）以及内存安全漏洞（包括使用后释放 UAF、重双释放 DF 等）。值得注意的是，前一类问题在 Rust 中虽然不直接导致未定义行为，但在高安全性场景下依然被视作安全隐患，因此 MirChecker 将其纳入检测范围。这使得 MirChecker 的检测广度超越了传统内存安全工具，仅仅聚焦未定义行为的范畴。而在 panic 相关的内存安全方面，MirChecker 与 Rudra 有一定重叠，即二者都能检测因 panic 触发的不安全场景。例如，当存在封装的 unsafe 代码在一半执行过程中 panic，导致某些对象的析构顺序混乱时，MirChecker 通过模拟 unwind 路径上的 drop 调用，有可能发现资源的重复释放或非法使用。不过，MirChecker 并未将这类情况单独归类为“panic 安全漏洞”，而是统一看作内存违规的一种情形（use-after-free 或 double-free）。在其实验评估中，MirChecker 成功发现了多个真实 crate 中的严重缺陷：作者扫描了 Crates.io 上下载量最高的 1000 个 Rust 包，以及部分 GitHub 上的未发布包，共检出 12 个包中 33 个漏洞，其中包括 17 个运行时 panic 相关错误和 16 个内存安全错误。这些漏洞经报告后已有大部分被确认修复。这一成果表明 MirChecker 在 Rust 实际代码中对 panic 相关问题（如越界 panic）和内存非法操作均具有较高的检出能力。

在模型假设方面，MirChecker 追求尽可能地全面和精确，但也做出了一些折衷。首先，它假设大部分重要逻辑在当前分析 crate 内可见，对于外部依赖库的调用以及 trait 动态派发的函数，默认不深入分析，而是跳过或采用预先定义的模型处理。这一简化在理论上引入了不完备性（unsoundness），但作者指出由于 Rust 强调零成本抽象，大多数实际代码倾向于使用静态分发，且如此设计可以避免分析无关的依赖代码，减轻状态空间爆炸。例如，调用外部 crate 的安全函数，MirChecker 通常不会跟踪其内部实现，而是信任其行为或通过已知模型（如对 Index、as_mut_ptr 等标准库函数定制的处理）来近似模拟。这种做法隐含假设了外部代码本身是安全或其潜在风险不影响当前分析目标，从而将注意力聚焦在本地代码的风险上。其次，MirChecker 针对某些容易产生误报的情况提供了配置开关。例如，位运算对抽象解释框架而言不易精确建模，可能引发大量假阳性警告，于是工具允许用户关闭此类检查路径，以提升结果的可靠性。最后，在检测 panic 相关问题时，MirChecker 等价地假定开发者期望程序无运行时 panic，因此将任何可致程序崩溃的路径都标记为问题，即使这些 panic 在 Rust 规范下不属于未定义行为。这是一种偏保守的安全假设，但符合安全关键应用场景的需求。综合来说，MirChecker 在设计上追求广覆盖、高精度，通过符号执行和约束求解缩减误报，同时接受在跨 crate 分析上的有限不完备性。其结果是能够在 Rust 程序中同时发现如整数溢出 panic 和 panic 引发的内存错误等不同层次的问题，为 panic 安全评测提供了一个全面的参考基线。

## SafeDrop

SafeDrop 是 Fudan 大学等提出的一种静态分析方法，专门用于检测 Rust 程序中由于资源自动回收机制而产生的内存释放错误。Rust 采用所有权机制和 RAII（资源获取即初始化）来自动管理资源，当变量离开作用域或发生 panic 进行栈展开时，所有权系统会自动调用 Drop 释放资源。然而，这种自动释放在 unsafe 代码配合下可能出现误释放：例如提早释放仍在使用的缓冲区，或者对悬空指针执行释放操作，分别对应经典的 use-after-free 和 double-free 漏洞。SafeDrop 关注的正是此类由 panic 引发或不当内存释放导致的安全问题，可以视为 Rust 异常（panic）安全问题在内存释放维度的具体化。论文中提及，多起真实漏洞（如 CVE-2019-16140、CVE-2019-16144 等）源于 Rust 自动释放机制处理 panic 时的不当行为：前者在缓冲区仍被引用时进行了释放，造成之后的访问变为悬空；后者对本应仅释放一次的资源执行了重复释放。这些漏洞反映出即便有编译器的所有权检查，配合 unsafe 代码绕过后，Rust 在异常（panic）情景下的内存安全仍可能受到威胁。SafeDrop 正是为提前捕获这类隐患而设计。

SafeDrop 的分析原理是基于 Rust MIR 的路径敏感数据流分析。它以每个 Rust crate 中的公开 API 函数为分析单位，遍历函数的控制流图（CFG），搜集程序运行过程中可能产生的所有别名关系，然后检查每一路径上每一个内存释放（drop 语句）的安全性。由于路径爆炸问题的存在，SafeDrop 在算法上进行了多项优化。首先，它采用**“路径覆盖”（meet-over-path, MOP）**的方法，通过改进的 Tarjan 强连通分量检测算法来合并循环中的冗余路径，仅保留“有价值”的路径进行分析。所谓有价值的路径指的是别名关系发生变化或影响释放安全性的执行路径；重复等价的循环执行不会重复分析，从而保障了路径敏感的同时提高了可扩展性。其次，在别名分析方面，SafeDrop 逐条路径追踪所有变量及其复合字段的指针别名集合，以流敏感的方式更新别名关系。当遇到函数调用时，SafeDrop 会递归地分析被调函数，将被调函数内部的别名关系（参数与返回值之间的所有权关联）反馈回来，与调用点的别名集成。为避免不同函数间重复分析，SafeDrop 引入结果缓存策略，对于已经分析过的函数直接复用其别名提取结果。通过上述策略，SafeDrop 实现了接近上下文敏感的跨过程分析，而开销仅相当于编译时间的 1 倍到 2 倍。作者将 SafeDrop 作为 Rust 编译器 v1.52 的一个查询 pass 实现，与编译过程集成，这使其能够利用编译器内部数据结构直接处理 MIR 并输出精确的警告位置。实验结果表明，SafeDrop 可以成功检出已知的所有此类内存释放漏洞 CVE，并且仅产生极少量误报。例如，对 8 个带有相关漏洞的真实 crate 运行 SafeDrop，均正确定位出了问题根源。这证明了该工具在 panic 相关的内存释放问题上具有高度有效性。

SafeDrop 覆盖的 panic 安全问题类型具体体现为：正在使用中的缓冲区被释放、悬空指针被释放以及由此延伸出的 use-after-free (UAF)、double-free (DF) 等模式。在工具实现中，作者将 Unsafe Rust 中遇到的此类模式形式化为若干种漏洞模式。如 Pattern 1：获取指针 -> 不安全构造新所有者 -> 释放 -> 随后继续使用，导致 UAF；Pattern 2：获取指针 -> 不安全构造新所有者 -> 释放 -> 再次释放，导致 DF。SafeDrop 通过静态分析一旦发现 MIR 中存在满足这些模式的执行路径（比如同一内存块上的两个 drop 调用序列，或先 drop 后继续调用的序列），就会产生警告。这等价于检测程序中是否存在违反异常安全的内存操作：例如上文提及的在 panic 展开时释放未初始化或重复释放的情形，在 SafeDrop 看来就是上述模式的具体实例。实际上，SafeDrop 对 panic 情景的考虑是内建于 MIR 控制流的：Rust 编译器在生成 MIR 时，会为可能 panic 的操作（如数组访问、显式 panic! 调用等）创建对应的 unwind 基本块，用于执行栈展开时的资源清理。SafeDrop 正是利用这些信息，分析所有正常路径和异常路径上的 drop 行为是否安全。因此，对于“如果此处 panic 会不会导致内存错误”这一问题，SafeDrop 能够给出确定的回答。当检测到不安全的释放路径时，SafeDrop 会发出详细的诊断，包括涉及的资源和路径位置，帮助开发者理解问题所在。SafeDrop 将 Rust 面对异常（panic）时内存释放可能出现的问题首次进行了系统性梳理和检测，大大提高了 Rust 在异常安全维度的健壮性。

SafeDrop 的模型假设相对明确：(1) Rust 内存管理的主要问题源自自动释放机制与 unsafe 代码交互。也就是说，它聚焦于 Rust 自身的 drop 行为，对于纯应用层逻辑导致的资源泄漏并不判定为漏洞（Rust 中内存泄漏被认为是内存安全的，不会造成未定义行为）。这点从 SafeDrop 发现的漏洞类型可以看出：其报告的都是 UAF 和 DF 之类真正危及内存安全的错误，而没有将内存泄漏归为安全问题。(2) 发生漏洞通常需要 unsafe 操作介入。SafeDrop 默认安全代码正确使用 RAII 不会有问题，只有 unsafe 绕过检查才可能导致错误释放。因此分析时也主要针对 unsafe 代码段进行深入别名跟踪。事实上 SafeDrop 能捕获的许多漏洞场景都涉及诸如 Vec::from_raw_parts、mem::forget 等 unsafe 函数或操作，如果一个 crate 完全不使用 unsafe，出现此类错误的可能性极低。(3) 程序执行以单线程、顺序语义为主。SafeDrop 当前并未专门处理数据竞争或并发下的内存释放问题，其分析基于 MIR 的单线程控制流。Rust 的 panic 在多线程情况下更复杂（例如线程 panic 的传播），但此类问题超出了 SafeDrop 设计范畴。总的来说，SafeDrop 通过聚焦 Rust 异常展开过程中资源释放的正确性，弥补了 Rust 编译器在这一细微领域的空白。它所做的假设使其分析既有针对性又有效率，确保了对 panic 相关内存安全漏洞的高检测率和低误报率。

## FFIChecker

FFIChecker 是一款针对 Rust 与其他语言（主要是 C/C++）交互边界处内存管理问题的静态分析工具，由香港中文大学和香港科大等合作在 ESORICS 2022 上提出。在 Rust 生态中，跨语言调用（FFI，Foreign Function Interface）非常普遍：大量 crate 通过 FFI 调用 C 库或提供给 C 使用。由于 Rust 编译器无法跨语言边界检查内存安全，不同语言的内存管理模型差异可能导致漏洞。例如，Rust 的所有权系统假定资源由所有者释放，而 C/C++ 依赖程序员手工管理内存。如果在 Rust 中调用 C 代码分配了内存却不返回所有权，Rust 端可能无法正确释放，造成内存泄漏；反之，如果 Rust 释放了由 C 管理的内存，或 C 重复释放了 Rust 已释放的内存，就会出现 double-free 等未定义行为。此外，Rust 的 panic 异常不能直接跨越 FFI 边界，否则会导致未定义行为；同样 C++ 异常进入 Rust 也不被 Rust 运行时所知，可能破坏 Rust 的堆栈结构。这些都是跨语言情境下的 panic 安全问题。FFIChecker 针对上述场景，通过静态分析在不执行程序的情况下检测潜在的跨语言内存管理漏洞，包括内存泄漏、异常（panic）安全问题以及由混用不同内存管理机制引发的未定义行为。

FFIChecker 的分析流程包含三个主要阶段：（1）收集跨语言 IR；（2）静态状态传播分析；（3）漏洞检测与报告。首先，工具利用编译基础设施收集目标 Rust 包的 LLVM IR，以及其依赖调用的 C/C++ 代码的 LLVM IR。这样，Rust 和 C 的代码都转化到统一的 IR 层次，便于联合分析。接着，FFIChecker 采用扩展的污点分析（taint analysis）方法，在 IR 控制流图上跟踪堆内存块的状态迁移。这里设计了一种名为 MState 的抽象格，用于刻画每一内存块可能所处的状态（例如“已分配但未释放”、“已释放”、“传递出 Rust 边界”等）。分析过程中，随着指令执行，工具应用传输函数更新这些状态。尤其关注内存分配与释放相关指令，以及 Rust 与 C 之间的边界调用：当发现内存通过 FFI 从 Rust 传递给外部代码时，记录该内存可能“泄露”到外部；当发现外部代码释放了来自 Rust 的内存或未释放应由其释放的内存时，标记相应状态。FFIChecker 通过在 Rust 函数返回后检查内存状态是否异常（例如应由 C 释放的内存 Rust 却仍标记为有效）来初步发现问题。随后，它针对可疑情况深入分析对应的外部函数实现，以确定内存最终是否被释放或错误释放，从而分类漏洞类型。例如，如果 Rust 将一块堆内存指针传给 C 函数且随后不再使用，而该 C 函数内部也没有释放它，则被判定为内存泄漏（LEAK）；如果 Rust 传出指针后自行释放了该内存，而 C 稍后又释放一次，则被判定为双重释放（属未定义行为 UB）；如果 Rust 在未标记 panic = abort 的情况下发生 panic 穿越 FFI 边界，或者 C++ 异常未被捕获地进入 Rust 代码，则属于异常安全问题（EXC）。FFIChecker 将这些类型的问题汇总报告，供开发者审查。在作者评估的 987 个 Rust 包中，工具共报告 222 条警告，人工确认其中 34 个真实漏洞，涉及 12 个仓库。这些漏洞包括 19 个内存泄漏、3 个异常安全问题和 12 个未定义行为（主要为 double-free 等）。已有超过 15 个漏洞在报告后被修复，印证了该工具对实际跨语言安全问题的发现价值。

FFIChecker 在模型上做出了一些重要假设。首先，它假设分析目标的跨语言边界是可知且代码可用的。也就是说，只有在能够获取到 C/C++ 源代码并生成 IR 的前提下，工具才能深入分析外部函数的行为。对于某些调用了共享库的情形，若库的实现不可用（例如只提供二进制），FFIChecker 会将相关调用标记为不确定并降低警告置信度。这种处理表明模型隐含假定大多数漏洞发生在可分析的第三方库中，而非系统库。其次，FFIChecker 聚焦堆内存管理的跨界问题，因此对栈上数据或其他资源（如文件句柄）的管理不在其检测范围。这是合理的，因为 Rust 主要通过所有权系统管理堆内存，而文件等资源泄漏不直接导致内存安全隐患。再次，对于 Rust 和 C 不同的异常机制，工具目前主要检测未受控的异常传播。Rust 的 panic 在缺省设置下会展开栈，如果跨越到 C 层将导致未定义行为；因此 FFIChecker 要求用户应在 FFI 边界使用 std::panic::catch_unwind 或将 panic 策略设置为 abort。类似地，C++ 异常进入 Rust 需被捕获或禁止。工具能发现未遵循这些规范的代码，但它假定异常本身不会在被分析代码中被处理，一旦发现有 panic/异常通过边界就报告。这是一个相对保守的假设，但覆盖了最危险的情形。最后，在精度与性能权衡上，FFIChecker 与 Rudra 类似选择了面向规模的近似分析：它没有尝试构造程序完全证明，而是通过静态污点跟踪快速检出可疑模式。尽管如此，其误报率被证明是可以接受的，每个包平均只产生不到 0.23 条警告（987 包 222 警告）。综上，FFIChecker 通过合理的假设和抽象，在 Rust FFI 场景下实现了对包括 panic 安全在内的跨语言内存问题的高效检测，填补了 Rust 安全工具在 FFI 维度的空白。

## 工具差异与共性分析

以上介绍的四款工具各自侧重于 Rust 内存安全的不同方面，在处理 panic 相关问题时既有区别也存在共性。首先，从分析对象和范围来看：Rudra 和 SafeDrop 主要面向 Rust 内部的 unsafe 代码分析。Rudra 聚焦于整个 Rust 生态中 crate 的 unsafe 代码模式，能够快速扫描数以万计的包以发现宏观层面的漏洞模式。SafeDrop 则深入单个 crate 内部，对每个函数的所有可能执行路径逐一验证 drop 操作安全与否。MirChecker 介于二者之间，它针对单个 crate 执行全面检查，但既分析 unsafe 代码也分析安全代码中可能触发 panic 的部分，覆盖面更广。相比之下，FFIChecker 扩展了 Rust 安全检查的疆界，将目光投向跨语言交互，填补了其他工具未涉及的 FFI 领域。因此，在 panic 相关问题上，Rudra 和 SafeDrop 关注的是 Rust 自身异常展开过程中的内存安全，MirChecker 既考虑 Rust 内部异常又考虑一般运行时错误，而 FFIChecker 则关心异常/错误跨越语言边界时的安全保障。

其次，就分析方法和模型假设而言，各工具各有侧重。Rudra 和 FFIChecker 采取了较为轻量级的静态污点/数据流分析，使用启发式规则快速发现可能的漏洞模式，目的是在尽可能大规模的代码库中保持可扩展性。这也使得它们倾向于在模型中做保守假设：如 Rudra 假定未解析泛型调用可能 panic，FFIChecker 假定未知外部函数可能隐藏问题。这种保守性带来了相对较高的误报率（如 Rudra 报告的结果中大部分需人工确认），但保证了对 panic 相关 bug“不漏掉”——宁可多报也不遗漏。相反，MirChecker 和 SafeDrop 走的是精细化分析路线。MirChecker 通过抽象解释和约束求解，以更严格的方式验证运行时 panic 和内存错误的可达性；SafeDrop 则采用路径敏感的完全别名分析来严谨地判断每一个 drop 调用的合法性。因此这两者在模型上引入了一些限制以控制复杂度：MirChecker 跳过外部依赖、限制分析深度来确保可计算；SafeDrop 假定只需关注经典的 drop 模式、忽略其它未定义行为种类来聚焦结果。它们都力图降低误报（MirChecker 可通过选项调整分析以减少虚警，SafeDrop 本身精度就较高），但相应的分析范围相对局限于模型覆盖的情形。不过在 panic 相关内存错误上，二者的模型恰好较为充分：MirChecker 能够捕捉到 panic 引发的典型内存违规场景（例如前文提到的 panic 中途导致的 use-after-free），SafeDrop 则完整列举了 panic 情况下错误释放资源的模式，因此在这一领域并未因假设缩小而遗漏主要问题。

在 panic 安全问题的具体处理方面，这些工具表现出如下共性：它们均认识到 panic/异常与内存安全交织的重要性，均将由于 panic 导致的内存不一致视为需要解决的安全问题。例如 Rudra 明确定义了 panic 安全漏洞类型并提供专门检测算法；SafeDrop 直接以检查 panic 展开中的 drop 安全为目标；MirChecker 虽然未独立分类“panic 安全”，但其内存检查涵盖了 panic 展开路径，确保 panic 不会触发隐藏的内存错误；FFIChecker 更是将“异常安全（EXC）”作为报告类别之一，专门标识跨语言的 panic/异常处理漏洞。可见，针对 panic 情景的内存安全保障是这些工具共同关注的焦点。此外，在实现上，大多数工具都不同程度地借助了 Rust 编译器中间表示（MIR/LLVM IR）来理解程序的控制流和资源生命周期：MirChecker、SafeDrop 直接基于 MIR 进行分析；Rudra 结合 HIR 和 MIR 获取 unsafe 操作和生命周期信息；FFIChecker 收集 LLVM IR 以跨越语言边界。这体现了一个共性理念：利用编译阶段信息提高分析准确度和便利性，避免从源代码文本进行脆弱的模式匹配。将工具嵌入编译过程或作为编译后步骤，也利于其在实际开发中部署（如 Rudra、MirChecker 实现为 Cargo 子命令，SafeDrop 集成编译器 pass，FFIChecker 与 Cargo 构建流程整合）。

当然，不同工具在 panic 相关问题上的着力点也有所差异。例如，Rudra 和 SafeDrop 都能发现因 panic 导致的双重释放漏洞，但 Rudra 可能通过检测“不变量破坏”模式间接发现，SafeDrop 则通过识别具体的 drop 序列直接定位。这意味着 Rudra 可能报告的问题更抽象（需人工确认具体是否发生 panic 条件），而 SafeDrop 给出的结论更具确定性。又比如，对于纯安全代码中的 panic 隐患，SafeDrop 和 Rudra 都不会理会（因为安全代码不会造成未定义行为），MirChecker 则会报告（因为无论 safe/unsafe，只要会 panic 都视为潜在 bug）。再如，跨语言的 panic 传播，只有 FFIChecker 涉及这一领域：Rudra 等假定 Rust 代码 panic 不会跨 FFI（典型做法是 abort 或捕获），而 FFIChecker 实际去检查这一假定是否被遵守。因此我们看到，各工具从不同层面保障了 Rust 程序在异常情况（panic 或跨语言异常）下的健壮性：水平上覆盖从 Rust 自身到 Rust + C 交互；垂直上涵盖从程序崩溃预防到内存一致性维护。

综合以上分析，我们可以为后续评测设计提炼出几点启示：(1) 评测指标需区分不同类型的 panic 相关问题，例如区分纯运行时错误（如除零 panic）与真正内存违规（如 panic 导致双重释放），因为不同工具对待它们的策略不同。(2) 评测样例集应涵盖多层次场景，包括 Rust 内部的 panic 安全案例以及跨 FFI 的异常处理案例，从而考察工具在各细分领域的有效性。(3) 对于每一道评测样例，需要考虑工具模型假设下能否处理：例如涉及复杂泛型或依赖库的 panic 案例，Rudra/MirChecker 可能有漏报，应在评测中有所体现。借助这四种工具的差异与共性分析，我们将在下文中制定针对 panic 安全问题的评测方案，以全面衡量各工具的能力边界和优缺点，为本研究的评测框架提供坚实依据。
