# Rust 非正常控制流下的内存安全问题研究：场景分类与静态分析能力边界评估

## 摘要与关键词
- 中文摘要（结构）
  - 背景：Rust 默认内存安全，但 panic 触发的非正常控制流与 Drop/unsafe/FFI 交互带来隐蔽风险
  - 问题：现有静态分析工具缺乏围绕 panic/展开语义的系统性评测与能力边界归纳
  - 方法：提出“非正常控制流场景分类 + 机制分析”；构建“基于场景分类的评测框架”；对比 Rudra/SafeDrop/MirChecker/FFIChecker
  - 结果：以覆盖/漏报/误报/可运行率等指标给出对比结论与能力边界
  - 贡献：分类体系 + 评测框架 + 可复现流程与建议
- 关键词：Rust；panic；非正常控制流；Drop；unsafe；FFI；静态分析；能力边界；漏洞挖掘

## 第 1 章 绪论
### 1.1 研究背景与意义
- 错误处理演进（返回值/错误码 → 类型化错误 → 异常控制流）
- Rust 的错误语义：Result（可恢复） vs panic（不可恢复）
- Rust 的“默认安全”与现实：unsafe/FFI 的存在与普遍性
- 关键切入点：panic 引发的栈展开/析构路径会让手工维护不变量失效 → 可能触发内存不安全
- 本研究意义：补齐“panic/展开语义”视角下的安全分析与工具评测空白

### 1.2 研究问题与挑战
- 挑战 1：非正常控制流（panic/unwind）路径难以被静态工具精确建模
- 挑战 2：漏洞复现依赖版本/编译配置（panic=unwind/abort）、库实现差异
- 挑战 3：现有分类多按 UAF/double-free 等“表象类型”，难贴合 panic 语义
- 挑战 4：评测指标与基准构建缺乏统一范式，导致结论难对比、难复现

### 1.3 研究目标与研究内容
- 目标：围绕 Rust 非正常控制流下的内存安全问题，提出体系化分类与静态分析评测框架
- 内容：
  - 建立非正常控制流场景分类并进行机制分析
  - 构建基于场景分类的评测框架与指标体系
  - 系统评估 4 类静态分析工具并总结能力边界

### 1.4 创新点
- 创新点 1：提出面向非正常控制流（panic/unwind）的场景分类体系，并给出机制级解释与漏洞后果映射
- 创新点 2：提出基于场景分类的静态分析评测框架（指标体系 + 可复现流程 + 结果归一化），产出工具能力边界图谱
- 创新点 3：形成可复用的最小触发样例模板与复现实践建议

### 1.5 论文结构安排
- 逐章简介

## 第 2 章 相关背景与技术基础
### 2.1 Rust 内存安全模型与资源管理
- 所有权、借用、生命周期的安全保证
- RAII 与 Drop：析构调用时机、作用域结束语义
- 手工资源管理与 unsafe：原始指针、手写释放、别名与不变量

### 2.2 Rust panic 机制与非正常控制流
- panic 来源：panic!、unwrap/expect、索引越界、断言失败等
- unwind vs abort：编译配置及其对安全分析/复现的影响
- 栈展开过程：逐帧析构、Drop 链条、部分初始化对象的风险点

### 2.3 非正常控制流下的 panic safety / exception safety 概念
- panic safety 定义：panic 发生后程序仍保持关键不变量与内存安全
- 与 C++ exception safety 的对照（basic/strong guarantee 的启发）
- Rust 特有边界：unsafe 不变量 + Drop 自动展开 + FFI ABI 约束

### 2.4 静态分析评测基础
- 工具评测常用维度：precision/recall、误报漏报、可运行性、成本
- Rust 静态分析常见 IR：AST/HIR/MIR
- 能力边界概念：支持哪些语义/路径/边界，在哪些条件下失效

## 第 3 章 相关工作与评测对象
### 3.1 研究对象选择与范围界定
- 选择 Rudra/SafeDrop/MirChecker/FFIChecker 的理由
- 研究范围：以 panic/展开语义触发的内存安全风险为中心
- 不做的部分：不深入工具源码细节、不追求复现所有 CVE

### 3.2 Rudra：面向 unsafe 误用的静态检测
- 检测目标、输出形式
- 与 panic safety 的关联
- 预期优势与盲区

### 3.3 SafeDrop：面向释放错误的静态检测
- 关注点：Drop/释放路径、double free/UAF 等
- 对非正常控制流的潜在敏感性

### 3.4 MirChecker：基于 MIR 的检查与约束分析
- 分析粒度：MIR 控制流、路径与约束
- 对 panic 路径、部分初始化、跨过程建模能力

### 3.5 FFIChecker：跨语言边界安全分析
- FFI 典型风险：资源所有权/释放责任不一致、异常跨边界
- 与 panic 直接关联：unwind 穿越 FFI 的风险与检测价值

### 3.6 本章小结
- 缺少“以非正常控制流为中心”的统一分类与统一评测框架

## 第 4 章 Rust 非正常控制流内存安全问题的场景分类与机制分析
### 4.1 分类动机与设计原则
- 不按 UAF/double free 等“表象类型”分类的原因
- 分类原则：语义贴合、可复现、可评测、可映射真实漏洞

### 4.2 场景化分类总体框架
- 场景维度：
  - 非正常控制流触发点位置（普通函数/Drop/清理逻辑/FFI）
  - 资源状态（未初始化/部分初始化/已释放/别名共享/手工维护）
  - 边界位置（safe/unsafe 边界、跨 crate、跨 FFI）

### 4.3 场景 S1：Drop 执行中途发生 panic
- 触发机制：析构函数内部可能 panic
- 机制分析：Drop 链条中断 → 半析构状态
- 典型后果：double free / UAF / 资源泄漏 / 状态污染
- 模板：析构函数中触发 panic 的资源清理流程

### 4.4 场景 S2：未初始化/部分初始化状态下 panic 中断
- 触发机制：MaybeUninit、手写 set_len、扩容/拷贝过程 panic
- 机制分析：不变量未建立完成却进入析构
- 典型后果：未初始化读、释放未分配、UAF
- 模板：MaybeUninit<T> + 手动长度管理 + panic 点

### 4.5 场景 S3：panic 跨 FFI 边界传播
- 触发机制：Rust 回调被 C 调用时 panic；或 Rust 调 C 后 panic 传播
- 机制分析：ABI/栈展开不匹配、两侧所有权契约破坏
- 典型后果：未定义行为、资源错配释放、崩溃/绕过清理
- 模板：extern "C" callback 中 panic + cleanup 责任不一致

### 4.6 场景 S4：自定义资源清理逻辑中 panic
- 触发机制：手写 guard、手写 allocator、手写事务性清理逻辑
- 机制分析：panic 打断手工恢复步骤 → Drop 又触发清理
- 典型后果：double free、UAF、泄露、状态不一致
- 模板：scope guard + 手动 free + panic

### 4.7 场景—漏洞类型映射与讨论
- S1–S4 ×（UAF / double free / uninit / leak / FFI-UB）映射表
- 讨论：后果分布与工具易漏场景

### 4.8 本章小结
- 输出：分类体系 + 各场景机制解释

## 第 5 章 基于场景分类的静态分析工具评测框架与能力边界分析
### 5.1 评测目标、问题定义与研究假设
- 评测目标：工具在 S1–S4 场景下的检测能力、可运行性与边界
- 研究问题：
  - RQ1：不同工具对不同场景的检出能力差异如何？
  - RQ2：造成漏报/误报的关键语义因素是什么？
  - RQ3：版本/构建约束对评测结论影响多大，如何保证可复现？
- 研究假设：各工具在特定场景存在系统性盲区

### 5.2 基准数据集构建策略
- 三层数据集：Micro-bench / Real-world / Regression
- 样例纳入标准：可触发非正常控制流、可定位资源不变量破坏点、可给出真值标签
- 版本锁定：rust-toolchain.toml、Cargo.lock、panic 策略、feature flags、profile
- 环境固化：容器/脚本

### 5.3 评测流程与结果归一化
- 评测管线：构建样例 → 运行工具 → 收集输出 → 归一化 → 人工确认 → 统计
- 归一化 schema：工具名、样例 ID、场景类别、告警位置、告警类型、置信度/规则 ID、运行状态
- 人工确认规则：检出/误报判定标准

### 5.4 指标体系
#### 5.4.1 基础指标
- Recall（每场景检出率）
- Precision（告警准确率）
- FNR（漏报率）
- 可运行率 Executability

#### 5.4.2 场景感知指标
- 场景覆盖率 Scenario Coverage
- Drop 感知度 Drop-awareness
- 边界感知度 Boundary-awareness

#### 5.4.3 成本指标
- 运行时间、资源占用
- 配置成本

### 5.5 能力边界分析方法
- 边界归因维度：控制流、数据流、语义、工程
- 输出形式：工具能力雷达/表格

### 5.6 有效性威胁与缓解
- 构念有效性、内部有效性、外部有效性
- 缓解：版本锁定、脚本化、双人复核

### 5.7 本章小结
- 输出：评测框架 + 指标体系 + 能力边界分析方法

## 第 6 章 实验与结果分析
### 6.1 实验环境与配置
- OS/CPU/RAM
- Rust 版本、工具版本
- 编译参数（尤其 panic 策略）

### 6.2 数据集概览
- 样例数量：Micro/Real/Regression
- 覆盖场景：S1–S4 分布

### 6.3 总体对比结果
- 总表：工具 × 场景 → TP/FP/FN/不可运行
- 关键图：每场景 Recall/Precision

### 6.4 分场景结果与误差分析
- S1 代表样例说明与工具表现
- S2 代表样例说明与工具表现
- S3 代表样例说明与工具表现
- S4 代表样例说明与工具表现

### 6.5 跨场景能力边界总结
- 能力边界图谱
- 结构性限制与可改进点

### 6.6 本章小结

## 第 7 章 总结与展望
### 7.1 工作总结
- 分类体系
- 评测框架与边界结论

### 7.2 局限性
- 样例规模、真实漏洞复现困难
- 静态分析局限

### 7.3 未来工作
- 扩展更大规模基准
- 引入动态验证/符号执行
- 面向 unwind/Drop 的静态建模增强

## 附录
- 附录 A：样例清单（ID、场景、Rust 版本、触发点、预期后果）
- 附录 B：工具运行脚本与命令
- 附录 C：人工判定标准与标签说明
- 附录 D：结果归一化表结构（schema）
